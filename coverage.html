
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>staticlang: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/sokoide/llvm5/cmd/staticlang/main.go (15.8%)</option>
				
				<option value="file1">github.com/sokoide/llvm5/codegen/generator.go (0.0%)</option>
				
				<option value="file2">github.com/sokoide/llvm5/grammar/parser.go (53.8%)</option>
				
				<option value="file3">github.com/sokoide/llvm5/grammar/parser_wrapper.go (66.7%)</option>
				
				<option value="file4">github.com/sokoide/llvm5/internal/application/compiler_factory.go (80.7%)</option>
				
				<option value="file5">github.com/sokoide/llvm5/internal/application/compiler_pipeline.go (22.0%)</option>
				
				<option value="file6">github.com/sokoide/llvm5/internal/domain/ast.go (43.6%)</option>
				
				<option value="file7">github.com/sokoide/llvm5/internal/domain/type_system.go (74.8%)</option>
				
				<option value="file8">github.com/sokoide/llvm5/internal/domain/types.go (0.0%)</option>
				
				<option value="file9">github.com/sokoide/llvm5/internal/infrastructure/error_reporter.go (79.8%)</option>
				
				<option value="file10">github.com/sokoide/llvm5/internal/infrastructure/llvm_backend.go (0.0%)</option>
				
				<option value="file11">github.com/sokoide/llvm5/internal/infrastructure/memory_manager.go (80.2%)</option>
				
				<option value="file12">github.com/sokoide/llvm5/internal/infrastructure/symboltable.go (100.0%)</option>
				
				<option value="file13">github.com/sokoide/llvm5/internal/interfaces/compiler.go (97.8%)</option>
				
				<option value="file14">github.com/sokoide/llvm5/lexer/lexer.go (75.6%)</option>
				
				<option value="file15">github.com/sokoide/llvm5/semantic/analyzer.go (68.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main provides the CLI interface for the StaticLang compiler
package main

import (
        "flag"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"

        "github.com/sokoide/llvm5/grammar"
        "github.com/sokoide/llvm5/internal/application"
        "github.com/sokoide/llvm5/internal/domain"
)

// Version information
const (
        Version = "0.1.0"
        Author  = "StaticLang Team"
)

// Command line flags
var (
        inputFiles        = flag.String("i", "", "Input source files (comma-separated)")
        outputFile        = flag.String("o", "", "Output file")
        optimizeLevel     = flag.Int("O", 0, "Optimization level (0-3)")
        debugInfo         = flag.Bool("g", false, "Generate debug information")
        targetTriple      = flag.String("target", "", "Target triple for code generation")
        warningsAsErrors  = flag.Bool("Werror", false, "Treat warnings as errors")
        verbose           = flag.Bool("v", false, "Verbose output")
        showVersion       = flag.Bool("version", false, "Show version information")
        showHelp          = flag.Bool("h", false, "Show this help message")
        useMockComponents = flag.Bool("mock", false, "Use mock components for testing")
        parserDebug       = flag.Int("parser-debug", 0, "Parser debug level (0-4)")
)

func main() <span class="cov0" title="0">{
        flag.Parse()

        if *showVersion </span><span class="cov0" title="0">{
                printVersion()
                return
        }</span>

        <span class="cov0" title="0">if *showHelp || *inputFiles == "" </span><span class="cov0" title="0">{
                printUsage()
                return
        }</span>

        <span class="cov0" title="0">grammar.SetDebugLevel(*parserDebug)

        // Parse input files
        files := strings.Split(*inputFiles, ",")
        for i, file := range files </span><span class="cov0" title="0">{
                files[i] = strings.TrimSpace(file)
        }</span>

        // Validate input files exist
        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                if _, err := os.Stat(file); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: Input file '%s' does not exist\n", file)
                        os.Exit(1)
                }</span>
        }

        // Determine output file
        <span class="cov0" title="0">output := *outputFile
        if output == "" </span><span class="cov0" title="0">{
                if len(files) == 1 </span><span class="cov0" title="0">{
                        ext := filepath.Ext(files[0])
                        output = files[0][:len(files[0])-len(ext)] + ".ll" // LLVM IR output
                }</span> else<span class="cov0" title="0"> {
                        output = "output.ll"
                }</span>
        }

        // Create compiler configuration
        <span class="cov0" title="0">config := application.CompilerConfig{
                UseMockComponents: *useMockComponents,
                MemoryManagerType: application.PooledMemoryManager,
                ErrorReporterType: application.ConsoleErrorReporter,
                CompilationOptions: domain.CompilationOptions{
                        OptimizationLevel: *optimizeLevel,
                        DebugInfo:         *debugInfo,
                        TargetTriple:      *targetTriple,
                        OutputPath:        output,
                        WarningsAsErrors:  *warningsAsErrors,
                },
                ErrorOutput: os.Stderr,
                Verbose:     *verbose,
        }

        // Create compiler factory
        factory := application.NewCompilerFactory(config)

        // Compile the files
        var err error
        if len(files) == 1 </span><span class="cov0" title="0">{
                err = compileSingleFile(factory, files[0], output, config)
        }</span> else<span class="cov0" title="0"> {
                err = compileMultipleFiles(factory, files, output, config)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Compilation failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                fmt.Printf("Compilation successful. Output written to: %s\n", output)
        }</span>
}

func compileSingleFile(factory *application.CompilerFactory, inputFile, outputFile string, config application.CompilerConfig) error <span class="cov0" title="0">{
        // Open input file
        input, err := os.Open(inputFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open input file: %w", err)
        }</span>
        <span class="cov0" title="0">defer input.Close()

        // Create output file
        output, err := os.Create(outputFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output file: %w", err)
        }</span>
        <span class="cov0" title="0">defer output.Close()

        // Create compiler pipeline
        pipeline := factory.CreateCompilerPipeline()

        if config.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("Compiling: %s -&gt; %s\n", inputFile, outputFile)
        }</span>

        // Compile
        <span class="cov0" title="0">err = pipeline.Compile(inputFile, input, output)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Print statistics if verbose
        <span class="cov0" title="0">if config.Verbose </span><span class="cov0" title="0">{
                if defaultPipeline, ok := pipeline.(*application.DefaultCompilerPipeline); ok </span><span class="cov0" title="0">{
                        stats := defaultPipeline.GetStats()
                        fmt.Printf("Compilation statistics:\n")
                        fmt.Printf("  Errors: %d\n", stats.ErrorCount)
                        fmt.Printf("  Warnings: %d\n", stats.WarningCount)
                        fmt.Printf("  Memory used: %d bytes\n", stats.MemoryUsage)
                        fmt.Printf("  Nodes created: %d\n", stats.NodesCreated)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func compileMultipleFiles(factory *application.CompilerFactory, inputFiles []string, outputFile string, config application.CompilerConfig) error <span class="cov0" title="0">{
        // Open all input files
        fileReaders := make(map[string]io.Reader)
        var filesToClose []io.Closer

        defer func() </span><span class="cov0" title="0">{
                for _, file := range filesToClose </span><span class="cov0" title="0">{
                        file.Close()
                }</span>
        }()

        <span class="cov0" title="0">for _, filename := range inputFiles </span><span class="cov0" title="0">{
                file, err := os.Open(filename)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open input file %s: %w", filename, err)
                }</span>
                <span class="cov0" title="0">fileReaders[filename] = file
                filesToClose = append(filesToClose, file)</span>
        }

        // Create output file
        <span class="cov0" title="0">output, err := os.Create(outputFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output file: %w", err)
        }</span>
        <span class="cov0" title="0">defer output.Close()

        // Create multi-file compiler pipeline
        pipeline := factory.CreateMultiFileCompilerPipeline()

        if config.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("Compiling multiple files: %v -&gt; %s\n", inputFiles, outputFile)
        }</span>

        // Compile all files
        <span class="cov0" title="0">err = pipeline.CompileFiles(fileReaders, output)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Print statistics if verbose
        <span class="cov0" title="0">if config.Verbose </span><span class="cov0" title="0">{
                stats := pipeline.GetStats()
                fmt.Printf("Multi-file compilation statistics:\n")
                fmt.Printf("  Files compiled: %d\n", len(inputFiles))
                fmt.Printf("  Errors: %d\n", stats.ErrorCount)
                fmt.Printf("  Warnings: %d\n", stats.WarningCount)
                fmt.Printf("  Memory used: %d bytes\n", stats.MemoryUsage)
                fmt.Printf("  Nodes created: %d\n", stats.NodesCreated)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func printVersion() <span class="cov8" title="1">{
        fmt.Printf("StaticLang Compiler %s\n", Version)
        fmt.Printf("Author: %s\n", Author)
        fmt.Printf("Built with Go %s\n", "1.21+")
}</span>

func printUsage() <span class="cov8" title="1">{
        fmt.Printf("StaticLang Compiler %s\n\n", Version)
        fmt.Printf("Usage: %s [options]\n\n", os.Args[0])
        fmt.Printf("Options:\n")
        flag.PrintDefaults()
        fmt.Printf("\nExamples:\n")
        fmt.Printf("  # Compile a single file\n")
        fmt.Printf("  %s -i main.sl -o main.ll\n", os.Args[0])
        fmt.Printf("\n  # Compile multiple files with optimization\n")
        fmt.Printf("  %s -i \"main.sl,lib.sl\" -o program.ll -O 2\n", os.Args[0])
        fmt.Printf("\n  # Compile with debug info and warnings as errors\n")
        fmt.Printf("  %s -i main.sl -o main.ll -g -Werror\n", os.Args[0])
        fmt.Printf("\n  # Use mock components for testing\n")
        fmt.Printf("  %s -i main.sl -o main.ll -mock -v\n", os.Args[0])
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package codegen

import (
        "fmt"
        "strings"

        "github.com/sokoide/llvm5/internal/domain"
        "github.com/sokoide/llvm5/internal/interfaces"
)

// Generator implements the CodeGenerator interface for LLVM IR generation
type Generator struct {
        backend       interfaces.LLVMBackend
        symbolTable   interfaces.SymbolTable
        typeRegistry  domain.TypeRegistry
        errorReporter domain.ErrorReporter
        output        strings.Builder
        indentLevel   int
        labelCounter  int
        functionName  string
        currentValue  string          // Holds the current expression result value
        currentType   string          // Holds the current expression result type
        parameters    map[string]bool // Track which identifiers are function parameters
}

// NewGenerator creates a new code generator
func NewGenerator() *Generator <span class="cov0" title="0">{
        return &amp;Generator{
                labelCounter: 0,
                parameters:   make(map[string]bool),
        }
}</span>

// SetLLVMBackend sets the LLVM backend
func (g *Generator) SetLLVMBackend(backend interfaces.LLVMBackend) <span class="cov0" title="0">{
        g.backend = backend
}</span>

// SetSymbolTable sets the symbol table
func (g *Generator) SetSymbolTable(table interfaces.SymbolTable) <span class="cov0" title="0">{
        g.symbolTable = table
}</span>

// SetTypeRegistry sets the type registry
func (g *Generator) SetTypeRegistry(registry domain.TypeRegistry) <span class="cov0" title="0">{
        g.typeRegistry = registry
}</span>

// SetErrorReporter sets the error reporter
func (g *Generator) SetErrorReporter(reporter domain.ErrorReporter) <span class="cov0" title="0">{
        g.errorReporter = reporter
}</span>

// Generate generates LLVM IR for the given AST
func (g *Generator) Generate(node domain.Node) (string, error) <span class="cov0" title="0">{
        g.output.Reset()
        g.indentLevel = 0
        g.labelCounter = 0

        // Initialize LLVM backend
        if g.backend != nil </span><span class="cov0" title="0">{
                if err := g.backend.Initialize("x86_64-apple-macosx10.15.0"); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to initialize LLVM backend: %v", err)
                }</span>
                <span class="cov0" title="0">defer g.backend.Dispose()</span>
        }

        // Generate the code
        <span class="cov0" title="0">err := node.Accept(g)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return g.output.String(), nil</span>
}

// Helper methods for code generation
func (g *Generator) emit(format string, args ...interface{}) <span class="cov0" title="0">{
        indent := strings.Repeat("  ", g.indentLevel)
        g.output.WriteString(indent)
        g.output.WriteString(fmt.Sprintf(format, args...))
        g.output.WriteString("\n")
}</span>

func (g *Generator) emitRaw(text string) <span class="cov0" title="0">{
        g.output.WriteString(text)
}</span>

func (g *Generator) newLabel(prefix string) string <span class="cov0" title="0">{
        g.labelCounter++
        return fmt.Sprintf("%s%d", prefix, g.labelCounter)
}</span>

// Visitor pattern implementation for AST nodes
func (g *Generator) VisitProgram(prog *domain.Program) error <span class="cov0" title="0">{
        // Emit LLVM module header
        g.emit("; ModuleID = 'staticlang'")
        g.emit("target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"")
        g.emit("target triple = \"x86_64-apple-macosx10.15.0\"")
        g.emit("")

        // Emit external function declarations
        g.emit("; External function declarations")
        g.emit("declare i32 @printf(i8*, ...)")
        g.emit("declare i8* @malloc(i64)")
        g.emit("declare void @free(i8*)")
        g.emit("")

        // Emit StaticLang builtin functions
        g.emit("; StaticLang builtin functions")
        g.emit("declare void @sl_print_int(i32)")
        g.emit("declare void @sl_print_double(double)")
        g.emit("declare void @sl_print_string(i8*)")
        g.emit("declare i8* @sl_alloc_string(i8*)")
        g.emit("declare i8* @sl_concat_string(i8*, i8*)")
        g.emit("declare i32 @sl_compare_string(i8*, i8*)")
        g.emit("declare i8* @sl_alloc_array(i64, i64)")
        g.emit("")

        // Process all declarations
        for _, decl := range prog.Declarations </span><span class="cov0" title="0">{
                if err := decl.Accept(g); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (g *Generator) generateGlobalVariable(varDecl *domain.VarDeclStmt) error <span class="cov0" title="0">{
        if varDecl.Initializer != nil </span><span class="cov0" title="0">{
                // Initialize with value
                if lit, ok := varDecl.Initializer.(*domain.LiteralExpr); ok </span><span class="cov0" title="0">{
                        switch varDecl.Type_.String() </span>{
                        case "int":<span class="cov0" title="0">
                                g.emit("@%s = global i32 %s, align 4", varDecl.Name, lit.Value)</span>
                        case "double":<span class="cov0" title="0">
                                g.emit("@%s = global double %s, align 8", varDecl.Name, lit.Value)</span>
                        case "string":<span class="cov0" title="0">
                                // String literals need special handling
                                strValue := strings.Trim(lit.Value.(string), "\"")
                                length := len(strValue) + 1
                                g.emit("@%s.str = private unnamed_addr constant [%d x i8] c\"%s\\00\", align 1", varDecl.Name, length, strValue)
                                g.emit("@%s = global i8* getelementptr inbounds ([%d x i8], [%d x i8]* @%s.str, i32 0, i32 0), align 8", varDecl.Name, length, length, varDecl.Name)</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Initialize with zero
                        switch varDecl.Type_.String() </span>{
                        case "int":<span class="cov0" title="0">
                                g.emit("@%s = global i32 0, align 4", varDecl.Name)</span>
                        case "double":<span class="cov0" title="0">
                                g.emit("@%s = global double 0.0, align 8", varDecl.Name)</span>
                        case "string":<span class="cov0" title="0">
                                g.emit("@%s = global i8* null, align 8", varDecl.Name)</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // Initialize with zero/null
                switch varDecl.Type_.String() </span>{
                case "int":<span class="cov0" title="0">
                        g.emit("@%s = global i32 0, align 4", varDecl.Name)</span>
                case "double":<span class="cov0" title="0">
                        g.emit("@%s = global double 0.0, align 8", varDecl.Name)</span>
                case "string":<span class="cov0" title="0">
                        g.emit("@%s = global i8* null, align 8", varDecl.Name)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (g *Generator) VisitFunctionDecl(node *domain.FunctionDecl) error <span class="cov0" title="0">{
        g.functionName = node.Name
        returnType := g.getLLVMType(node.ReturnType)

        // Clear and track parameters for this function
        g.parameters = make(map[string]bool)
        for _, param := range node.Parameters </span><span class="cov0" title="0">{
                g.parameters[param.Name] = true
        }</span>

        // Generate function signature
        <span class="cov0" title="0">paramStr := ""
        for i, param := range node.Parameters </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        paramStr += ", "
                }</span>
                <span class="cov0" title="0">paramStr += fmt.Sprintf("%s %%%s", g.getLLVMType(param.Type), param.Name)</span>
        }

        <span class="cov0" title="0">g.emit("define %s @%s(%s) {", returnType, node.Name, paramStr)
        g.emit("entry:")
        g.indentLevel++

        // Allocate parameters on stack
        for _, param := range node.Parameters </span><span class="cov0" title="0">{
                g.emit("%%%s.addr = alloca %s, align %d", param.Name, g.getLLVMType(param.Type), g.getTypeAlign(param.Type))
                g.emit("store %s %%%s, ptr %%%s.addr, align %d", g.getLLVMType(param.Type), param.Name, param.Name, g.getTypeAlign(param.Type))
        }</span>

        // Generate function body
        <span class="cov0" title="0">if err := node.Body.Accept(g); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if the function already has a return statement by examining the output
        // If not, add a default return
        <span class="cov0" title="0">outputStr := g.output.String()
        lines := strings.Split(outputStr, "\n")
        hasReturn := false
        for i := len(lines) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                line := strings.TrimSpace(lines[i])
                if line == "" || line == "}" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.HasPrefix(line, "ret ") </span><span class="cov0" title="0">{
                        hasReturn = true
                        break</span>
                }
                // If we encounter any other instruction, we assume no return
                <span class="cov0" title="0">if line != "" </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        // Only add default return if there's no explicit return
        <span class="cov0" title="0">if !hasReturn </span><span class="cov0" title="0">{
                if node.ReturnType.String() == "void" </span><span class="cov0" title="0">{
                        g.emit("ret void")
                }</span> else<span class="cov0" title="0"> if node.Name == "main" </span><span class="cov0" title="0">{
                        g.emit("ret i32 0")
                }</span>
        }

        <span class="cov0" title="0">g.indentLevel--
        g.emit("}")
        g.emit("")

        return nil</span>
}

func (g *Generator) VisitStructDecl(node *domain.StructDecl) error <span class="cov0" title="0">{
        // Not implemented for now
        return fmt.Errorf("struct declarations not yet implemented")
}</span>

func (g *Generator) VisitBlockStmt(node *domain.BlockStmt) error <span class="cov0" title="0">{
        for _, stmt := range node.Statements </span><span class="cov0" title="0">{
                if err := stmt.Accept(g); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (g *Generator) VisitVarDeclStmt(node *domain.VarDeclStmt) error <span class="cov0" title="0">{
        llvmType := g.getLLVMType(node.Type_)
        align := g.getTypeAlign(node.Type_)

        // Allocate local variable
        g.emit("%%%s = alloca %s, align %d", node.Name, llvmType, align)

        // Initialize if there's an initializer
        if node.Initializer != nil </span><span class="cov0" title="0">{
                if err := node.Initializer.Accept(g); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // The expression result should be in g.currentValue
                <span class="cov0" title="0">g.emit("store %s %s, ptr %%%s, align %d", llvmType, g.currentValue, node.Name, align)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (g *Generator) VisitAssignStmt(node *domain.AssignStmt) error <span class="cov0" title="0">{
        // Generate code for the expression (value)
        if err := node.Value.Accept(g); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Store the result into the target
        <span class="cov0" title="0">varType := g.getLLVMType(node.Target.GetType())
        align := g.getTypeAlign(node.Target.GetType())

        if ident, ok := node.Target.(*domain.IdentifierExpr); ok </span><span class="cov0" title="0">{
                g.emit("store %s %s, ptr %%%s, align %d", varType, g.currentValue, ident.Name, align)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (g *Generator) VisitIfStmt(node *domain.IfStmt) error <span class="cov0" title="0">{
        thenLabel := g.newLabel("if.then")
        elseLabel := g.newLabel("if.else")
        endLabel := g.newLabel("if.end")

        // Generate condition
        if err := node.Condition.Accept(g); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">conditionReg := g.currentValue

        // Branch based on condition
        if node.ElseStmt != nil </span><span class="cov0" title="0">{
                g.emit("br i1 %s, label %%%s, label %%%s", conditionReg, thenLabel, elseLabel)
        }</span> else<span class="cov0" title="0"> {
                g.emit("br i1 %s, label %%%s, label %%%s", conditionReg, thenLabel, endLabel)
        }</span>

        // Then block
        <span class="cov0" title="0">g.indentLevel--
        g.emit("%s:", thenLabel)
        g.indentLevel++
        if err := node.ThenStmt.Accept(g); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if the then block ends with a return statement
        // If so, don't add a branch to avoid unreachable code
        <span class="cov0" title="0">outputStr := g.output.String()
        lines := strings.Split(outputStr, "\n")
        lastNonEmptyLine := ""
        for i := len(lines) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                line := strings.TrimSpace(lines[i])
                if line != "" </span><span class="cov0" title="0">{
                        lastNonEmptyLine = line
                        break</span>
                }
        }

        <span class="cov0" title="0">thenHasReturn := strings.HasPrefix(lastNonEmptyLine, "ret ")
        if !thenHasReturn </span><span class="cov0" title="0">{
                g.emit("br label %%%s", endLabel)
        }</span>

        // Else block (if exists)
        <span class="cov0" title="0">if node.ElseStmt != nil </span><span class="cov0" title="0">{
                g.indentLevel--
                g.emit("%s:", elseLabel)
                g.indentLevel++
                if err := node.ElseStmt.Accept(g); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Check if the else block ends with a return statement
                <span class="cov0" title="0">outputStr = g.output.String()
                lines = strings.Split(outputStr, "\n")
                lastNonEmptyLine = ""
                for i := len(lines) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        line := strings.TrimSpace(lines[i])
                        if line != "" </span><span class="cov0" title="0">{
                                lastNonEmptyLine = line
                                break</span>
                        }
                }

                <span class="cov0" title="0">elseHasReturn := strings.HasPrefix(lastNonEmptyLine, "ret ")
                if !elseHasReturn </span><span class="cov0" title="0">{
                        g.emit("br label %%%s", endLabel)
                }</span>
        }

        // Only emit the end block if it's reachable
        // (i.e., if at least one branch doesn't end with return)
        <span class="cov0" title="0">needsEndBlock := !thenHasReturn || (node.ElseStmt != nil &amp;&amp; !strings.HasPrefix(lastNonEmptyLine, "ret "))
        if node.ElseStmt == nil </span><span class="cov0" title="0">{
                needsEndBlock = true // Always need end block if there's no else
        }</span>

        <span class="cov0" title="0">if needsEndBlock </span><span class="cov0" title="0">{
                g.indentLevel--
                g.emit("%s:", endLabel)
                g.indentLevel++
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (g *Generator) VisitWhileStmt(node *domain.WhileStmt) error <span class="cov0" title="0">{
        condLabel := g.newLabel("while.cond")
        bodyLabel := g.newLabel("while.body")
        endLabel := g.newLabel("while.end")

        // Jump to condition
        g.emit("br label %%%s", condLabel)

        // Condition block
        g.indentLevel--
        g.emit("%s:", condLabel)
        g.indentLevel++
        if err := node.Condition.Accept(g); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">conditionReg := g.currentValue
        g.emit("br i1 %s, label %%%s, label %%%s", conditionReg, bodyLabel, endLabel)

        // Body block
        g.indentLevel--
        g.emit("%s:", bodyLabel)
        g.indentLevel++
        if err := node.Body.Accept(g); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">g.emit("br label %%%s", condLabel)

        // End block
        g.indentLevel--
        g.emit("%s:", endLabel)
        g.indentLevel++

        return nil</span>
}

func (g *Generator) VisitForStmt(node *domain.ForStmt) error <span class="cov0" title="0">{
        // Initialize
        if node.Init != nil </span><span class="cov0" title="0">{
                if err := node.Init.Accept(g); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">condLabel := g.newLabel("for.cond")
        bodyLabel := g.newLabel("for.body")
        incLabel := g.newLabel("for.inc")
        endLabel := g.newLabel("for.end")

        // Jump to condition
        g.emit("br label %%%s", condLabel)

        // Condition block
        g.indentLevel--
        g.emit("%s:", condLabel)
        g.indentLevel++
        if node.Condition != nil </span><span class="cov0" title="0">{
                if err := node.Condition.Accept(g); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">conditionReg := g.currentValue
                g.emit("br i1 %s, label %%%s, label %%%s", conditionReg, bodyLabel, endLabel)</span>
        } else<span class="cov0" title="0"> {
                g.emit("br label %%%s", bodyLabel)
        }</span>

        // Body block
        <span class="cov0" title="0">g.indentLevel--
        g.emit("%s:", bodyLabel)
        g.indentLevel++
        if err := node.Body.Accept(g); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">g.emit("br label %%%s", incLabel)

        // Increment block
        g.indentLevel--
        g.emit("%s:", incLabel)
        g.indentLevel++
        if node.Update != nil </span><span class="cov0" title="0">{
                if err := node.Update.Accept(g); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">g.emit("br label %%%s", condLabel)

        // End block
        g.indentLevel--
        g.emit("%s:", endLabel)
        g.indentLevel++

        return nil</span>
}

func (g *Generator) VisitReturnStmt(node *domain.ReturnStmt) error <span class="cov0" title="0">{
        if node.Value != nil </span><span class="cov0" title="0">{
                if err := node.Value.Accept(g); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">returnType := g.getLLVMType(node.Value.GetType())
                g.emit("ret %s %s", returnType, g.currentValue)</span>
        } else<span class="cov0" title="0"> {
                g.emit("ret void")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (g *Generator) VisitExprStmt(node *domain.ExprStmt) error <span class="cov0" title="0">{
        return node.Expression.Accept(g)
}</span>

func (g *Generator) VisitBinaryExpr(node *domain.BinaryExpr) error <span class="cov0" title="0">{
        // Generate left operand
        if err := node.Left.Accept(g); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">leftReg := g.currentValue

        // Generate right operand
        if err := node.Right.Accept(g); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rightReg := g.currentValue

        // Generate unique temporary register
        tempReg := fmt.Sprintf("%%temp_%d", g.labelCounter)
        g.labelCounter++

        // Perform operation based on operator
        resultType := g.getLLVMType(node.GetType())

        switch node.Operator </span>{
        case domain.Add:<span class="cov0" title="0">
                if resultType == "i32" </span><span class="cov0" title="0">{
                        g.emit("%s = add i32 %s, %s", tempReg, leftReg, rightReg)
                }</span> else<span class="cov0" title="0"> if resultType == "double" </span><span class="cov0" title="0">{
                        g.emit("%s = fadd double %s, %s", tempReg, leftReg, rightReg)
                }</span>
        case domain.Sub:<span class="cov0" title="0">
                if resultType == "i32" </span><span class="cov0" title="0">{
                        g.emit("%s = sub i32 %s, %s", tempReg, leftReg, rightReg)
                }</span> else<span class="cov0" title="0"> if resultType == "double" </span><span class="cov0" title="0">{
                        g.emit("%s = fsub double %s, %s", tempReg, leftReg, rightReg)
                }</span>
        case domain.Mul:<span class="cov0" title="0">
                if resultType == "i32" </span><span class="cov0" title="0">{
                        g.emit("%s = mul i32 %s, %s", tempReg, leftReg, rightReg)
                }</span> else<span class="cov0" title="0"> if resultType == "double" </span><span class="cov0" title="0">{
                        g.emit("%s = fmul double %s, %s", tempReg, leftReg, rightReg)
                }</span>
        case domain.Div:<span class="cov0" title="0">
                if resultType == "i32" </span><span class="cov0" title="0">{
                        g.emit("%s = sdiv i32 %s, %s", tempReg, leftReg, rightReg)
                }</span> else<span class="cov0" title="0"> if resultType == "double" </span><span class="cov0" title="0">{
                        g.emit("%s = fdiv double %s, %s", tempReg, leftReg, rightReg)
                }</span>
        case domain.Eq:<span class="cov0" title="0">
                if node.Left.GetType().String() == "int" </span><span class="cov0" title="0">{
                        g.emit("%s = icmp eq i32 %s, %s", tempReg, leftReg, rightReg)
                }</span> else<span class="cov0" title="0"> if node.Left.GetType().String() == "double" </span><span class="cov0" title="0">{
                        g.emit("%s = fcmp oeq double %s, %s", tempReg, leftReg, rightReg)
                }</span>
        case domain.Ne:<span class="cov0" title="0">
                if node.Left.GetType().String() == "int" </span><span class="cov0" title="0">{
                        g.emit("%s = icmp ne i32 %s, %s", tempReg, leftReg, rightReg)
                }</span> else<span class="cov0" title="0"> if node.Left.GetType().String() == "double" </span><span class="cov0" title="0">{
                        g.emit("%s = fcmp one double %s, %s", tempReg, leftReg, rightReg)
                }</span>
        case domain.Lt:<span class="cov0" title="0">
                if node.Left.GetType().String() == "int" </span><span class="cov0" title="0">{
                        g.emit("%s = icmp slt i32 %s, %s", tempReg, leftReg, rightReg)
                }</span> else<span class="cov0" title="0"> if node.Left.GetType().String() == "double" </span><span class="cov0" title="0">{
                        g.emit("%s = fcmp olt double %s, %s", tempReg, leftReg, rightReg)
                }</span>
        case domain.Gt:<span class="cov0" title="0">
                if node.Left.GetType().String() == "int" </span><span class="cov0" title="0">{
                        g.emit("%s = icmp sgt i32 %s, %s", tempReg, leftReg, rightReg)
                }</span> else<span class="cov0" title="0"> if node.Left.GetType().String() == "double" </span><span class="cov0" title="0">{
                        g.emit("%s = fcmp ogt double %s, %s", tempReg, leftReg, rightReg)
                }</span>
        case domain.Le:<span class="cov0" title="0">
                if node.Left.GetType().String() == "int" </span><span class="cov0" title="0">{
                        g.emit("%s = icmp sle i32 %s, %s", tempReg, leftReg, rightReg)
                }</span> else<span class="cov0" title="0"> if node.Left.GetType().String() == "double" </span><span class="cov0" title="0">{
                        g.emit("%s = fcmp ole double %s, %s", tempReg, leftReg, rightReg)
                }</span>
        case domain.Ge:<span class="cov0" title="0">
                if node.Left.GetType().String() == "int" </span><span class="cov0" title="0">{
                        g.emit("%s = icmp sge i32 %s, %s", tempReg, leftReg, rightReg)
                }</span> else<span class="cov0" title="0"> if node.Left.GetType().String() == "double" </span><span class="cov0" title="0">{
                        g.emit("%s = fcmp oge double %s, %s", tempReg, leftReg, rightReg)
                }</span>
        }

        // Update current value for parent expressions
        <span class="cov0" title="0">g.currentValue = tempReg
        g.currentType = resultType

        return nil</span>
}

func (g *Generator) VisitUnaryExpr(node *domain.UnaryExpr) error <span class="cov0" title="0">{
        if err := node.Operand.Accept(g); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch node.Operator </span>{
        case domain.Neg:<span class="cov0" title="0">
                if node.GetType().String() == "int" </span><span class="cov0" title="0">{
                        g.emit("%%temp_result = sub i32 0, %%temp_result")
                }</span> else<span class="cov0" title="0"> if node.GetType().String() == "double" </span><span class="cov0" title="0">{
                        g.emit("%%temp_result = fsub double 0.0, %%temp_result")
                }</span>
        case domain.Not:<span class="cov0" title="0">
                g.emit("%%temp_result = icmp eq i1 %%temp_result, false")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (g *Generator) VisitCallExpr(node *domain.CallExpr) error <span class="cov0" title="0">{
        // Special handling for built-in print function
        if ident, ok := node.Function.(*domain.IdentifierExpr); ok &amp;&amp; ident.Name == "print" </span><span class="cov0" title="0">{
                return g.handlePrintFunction(node)
        }</span>

        // Generate arguments for regular function calls
        <span class="cov0" title="0">var argValues []string
        var argTypes []string
        for _, arg := range node.Args </span><span class="cov0" title="0">{
                if err := arg.Accept(g); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">argType := g.getLLVMType(arg.GetType())
                argTypes = append(argTypes, argType)
                argValues = append(argValues, fmt.Sprintf("%s %s", argType, g.currentValue))</span>
        }

        // Determine function name (assume identifier)
        <span class="cov0" title="0">funcName := "&lt;unknown&gt;"
        if ident, ok := node.Function.(*domain.IdentifierExpr); ok </span><span class="cov0" title="0">{
                funcName = ident.Name
        }</span>

        // Generate unique temporary register for the result
        <span class="cov0" title="0">tempReg := fmt.Sprintf("%%temp_%d", g.labelCounter)
        g.labelCounter++

        // Generate function call
        returnType := g.getLLVMType(node.GetType())
        argsStr := ""
        if len(argValues) &gt; 0 </span><span class="cov0" title="0">{
                argsStr = fmt.Sprintf("%s", strings.Join(argValues, ", "))
        }</span>

        <span class="cov0" title="0">if returnType == "void" </span><span class="cov0" title="0">{
                g.emit("call void @%s(%s)", funcName, argsStr)
                g.currentValue = ""
                g.currentType = "void"
        }</span> else<span class="cov0" title="0"> {
                g.emit("%s = call %s @%s(%s)", tempReg, returnType, funcName, argsStr)
                g.currentValue = tempReg
                g.currentType = returnType
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handlePrintFunction handles both simple print(value) and formatted print("format", args...)
func (g *Generator) handlePrintFunction(node *domain.CallExpr) error <span class="cov0" title="0">{
        if len(node.Args) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("print function requires at least one argument")
        }</span>

        // Single argument: use builtin sl_print_* functions
        <span class="cov0" title="0">if len(node.Args) == 1 </span><span class="cov0" title="0">{
                if err := node.Args[0].Accept(g); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">argType := node.Args[0].GetType().String()
                switch argType </span>{
                case "int":<span class="cov0" title="0">
                        g.emit("call void @sl_print_int(i32 %s)", g.currentValue)</span>
                case "double":<span class="cov0" title="0">
                        g.emit("call void @sl_print_double(double %s)", g.currentValue)</span>
                case "string":<span class="cov0" title="0">
                        g.emit("call void @sl_print_string(i8* %s)", g.currentValue)</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unsupported type for print: %s", argType)</span>
                }

                // print functions are void, set current value accordingly
                <span class="cov0" title="0">g.currentValue = ""
                g.currentType = "void"
                return nil</span>
        }

        // Multiple arguments: formatted printing with printf
        // First argument should be format string
        <span class="cov0" title="0">if err := node.Args[0].Accept(g); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if node.Args[0].GetType().String() != "string" </span><span class="cov0" title="0">{
                return fmt.Errorf("first argument to print must be a string for formatted printing")
        }</span>

        <span class="cov0" title="0">formatValue := g.currentValue

        // Get the actual format string for validation (if it's a literal)
        var formatStr string
        if lit, ok := node.Args[0].(*domain.LiteralExpr); ok </span><span class="cov0" title="0">{
                if strVal, ok := lit.Value.(string); ok </span><span class="cov0" title="0">{
                        formatStr = strings.Trim(strVal, "\"")
                }</span>
        }

        // Generate remaining arguments
        <span class="cov0" title="0">var argValues []string
        var argTypes []string
        for i := 1; i &lt; len(node.Args); i++ </span><span class="cov0" title="0">{
                if err := node.Args[i].Accept(g); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">argType := g.getLLVMType(node.Args[i].GetType())
                typeStr := node.Args[i].GetType().String()
                argTypes = append(argTypes, typeStr)
                argValues = append(argValues, fmt.Sprintf("%s %s", argType, g.currentValue))</span>
        }

        // Validate format string if we have it as a literal
        <span class="cov0" title="0">if formatStr != "" </span><span class="cov0" title="0">{
                if err := g.validateFormatArguments(formatStr, argTypes); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("format string validation failed: %v", err)
                }</span>
        }

        // Generate printf call
        <span class="cov0" title="0">tempReg := fmt.Sprintf("%%temp_%d", g.labelCounter)
        g.labelCounter++

        argsStr := fmt.Sprintf("i8* %s", formatValue)
        if len(argValues) &gt; 0 </span><span class="cov0" title="0">{
                argsStr += ", " + strings.Join(argValues, ", ")
        }</span>

        <span class="cov0" title="0">g.emit("%s = call i32 (i8*, ...) @printf(%s)", tempReg, argsStr)
        g.currentValue = tempReg
        g.currentType = "i32"

        return nil</span>
}

func (g *Generator) VisitIdentifierExpr(node *domain.IdentifierExpr) error <span class="cov0" title="0">{
        varType := g.getLLVMType(node.GetType())
        align := g.getTypeAlign(node.GetType())

        // Generate a unique temporary register name
        tempReg := fmt.Sprintf("%%temp_%d", g.labelCounter)
        g.labelCounter++

        // Determine whether to use .addr suffix based on whether it's a parameter
        var varName string
        if g.parameters[node.Name] </span><span class="cov0" title="0">{
                // This is a function parameter, use .addr suffix
                varName = fmt.Sprintf("%%%s.addr", node.Name)
        }</span> else<span class="cov0" title="0"> {
                // This is a local variable, use direct name
                varName = fmt.Sprintf("%%%s", node.Name)
        }</span>

        <span class="cov0" title="0">g.emit("%s = load %s, ptr %s, align %d", tempReg, varType, varName, align)

        // Store the result for use by parent expressions
        g.currentValue = tempReg
        g.currentType = varType

        return nil</span>
}

func (g *Generator) VisitLiteralExpr(node *domain.LiteralExpr) error <span class="cov0" title="0">{
        switch node.GetType().String() </span>{
        case "int":<span class="cov0" title="0">
                if val, ok := node.Value.(int64); ok </span><span class="cov0" title="0">{
                        // For integer literals, we can directly use the value in ret statement
                        // But if we need a temp variable, we should allocate and store
                        g.currentValue = fmt.Sprintf("%d", val)
                        g.currentType = "i32"
                }</span> else<span class="cov0" title="0"> {
                        // Fallback for safety, though parser should ensure int64
                        g.currentValue = fmt.Sprintf("%s", node.Value)
                        g.currentType = "i32"
                }</span>
        case "double":<span class="cov0" title="0">
                if val, ok := node.Value.(float64); ok </span><span class="cov0" title="0">{
                        g.currentValue = fmt.Sprintf("%f", val)
                        g.currentType = "double"
                }</span> else<span class="cov0" title="0"> {
                        // Fallback for safety
                        g.currentValue = fmt.Sprintf("%s", node.Value)
                        g.currentType = "double"
                }</span>
        case "string":<span class="cov0" title="0">
                // String literals need special handling
                strValue := strings.Trim(node.Value.(string), "\"")
                length := len(strValue) + 1
                labelName := g.newLabel("str")
                g.emit("@%s = private unnamed_addr constant [%d x i8] c\"%s\\00\", align 1", labelName, length, strValue)
                g.currentValue = fmt.Sprintf("getelementptr inbounds ([%d x i8], [%d x i8]* @%s, i32 0, i32 0)", length, length, labelName)
                g.currentType = "i8*"</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (g *Generator) VisitIndexExpr(node *domain.IndexExpr) error <span class="cov0" title="0">{
        // Not implemented for now
        return fmt.Errorf("index expressions not yet implemented")
}</span>

func (g *Generator) VisitMemberExpr(node *domain.MemberExpr) error <span class="cov0" title="0">{
        // Not implemented for now
        return fmt.Errorf("member expressions not yet implemented")
}</span>

// Helper functions
func (g *Generator) getLLVMType(t domain.Type) string <span class="cov0" title="0">{
        switch t.String() </span>{
        case "int":<span class="cov0" title="0">
                return "i32"</span>
        case "double":<span class="cov0" title="0">
                return "double"</span>
        case "string":<span class="cov0" title="0">
                return "i8*"</span>
        case "bool":<span class="cov0" title="0">
                return "i1"</span>
        case "void":<span class="cov0" title="0">
                return "void"</span>
        default:<span class="cov0" title="0">
                return "i32"</span> // fallback
        }
}

func (g *Generator) getTypeAlign(t domain.Type) int <span class="cov0" title="0">{
        switch t.String() </span>{
        case "int":<span class="cov0" title="0">
                return 4</span>
        case "double":<span class="cov0" title="0">
                return 8</span>
        case "string":<span class="cov0" title="0">
                return 8</span>
        case "bool":<span class="cov0" title="0">
                return 1</span>
        default:<span class="cov0" title="0">
                return 4</span>
        }
}

// parseFormatString analyzes a printf-style format string and returns expected argument types
func (g *Generator) parseFormatString(formatStr string) ([]string, error) <span class="cov0" title="0">{
        var expectedTypes []string

        for i := 0; i &lt; len(formatStr); i++ </span><span class="cov0" title="0">{
                if formatStr[i] == '%' </span><span class="cov0" title="0">{
                        if i+1 &gt;= len(formatStr) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("incomplete format specifier at end of string")
                        }</span>

                        <span class="cov0" title="0">switch formatStr[i+1] </span>{
                        case 'd', 'i':<span class="cov0" title="0">
                                expectedTypes = append(expectedTypes, "int")</span>
                        case 'f', 'g', 'e':<span class="cov0" title="0">
                                expectedTypes = append(expectedTypes, "float")</span> // StaticLang uses float, not double
                        case 's':<span class="cov0" title="0">
                                expectedTypes = append(expectedTypes, "string")</span>
                        case 'c':<span class="cov0" title="0">
                                expectedTypes = append(expectedTypes, "int")</span> // char is passed as int
                        case '%':<span class="cov0" title="0"></span>
                                // %% is escaped %, no argument needed
                        default:<span class="cov0" title="0">
                                return nil, fmt.Errorf("unsupported format specifier: %%%c", formatStr[i+1])</span>
                        }
                        <span class="cov0" title="0">i++</span> // Skip the format character
                }
        }

        <span class="cov0" title="0">return expectedTypes, nil</span>
}

// validateFormatArguments checks if the provided arguments match the format string expectations
func (g *Generator) validateFormatArguments(formatStr string, argTypes []string) error <span class="cov0" title="0">{
        expectedTypes, err := g.parseFormatString(formatStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(expectedTypes) != len(argTypes) </span><span class="cov0" title="0">{
                return fmt.Errorf("format string expects %d arguments, got %d", len(expectedTypes), len(argTypes))
        }</span>

        <span class="cov0" title="0">for i, expected := range expectedTypes </span><span class="cov0" title="0">{
                actual := argTypes[i]
                if expected != actual </span><span class="cov0" title="0">{
                        return fmt.Errorf("format argument %d: expected %s, got %s", i+1, expected, actual)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by goyacc -v y.output -o parser.go -l staticlang.y. DO NOT EDIT.
// Package grammar contains the Yacc parser for StaticLang
//
// This grammar defines the syntax for the StaticLang programming language,
// a statically-typed language with functions, structs, and control flow.
//
// Grammar Structure:
//   1. Headers and imports
//   2. Union and token definitions
//   3. Operator precedence rules
//   4. Grammar productions organized by:
//      - Program structure (program, declarations)
//      - Type system (types, parameters, fields)
//      - Statements (control flow, assignments)
//      - Expressions (binary, unary, primary)
//   5. Helper functions for location tracking

package grammar

import __yyfmt__ "fmt"

import (
        "fmt"
        "strconv"

        "github.com/sokoide/llvm5/internal/domain"
        "github.com/sokoide/llvm5/internal/interfaces"
)

type yySymType struct {
        yys int
        // Tokens and primitives
        token   interfaces.Token
        str     string
        num     int64
        float   float64
        boolean bool

        // AST node types
        program *domain.Program
        decl    domain.Declaration
        decls   []domain.Declaration
        stmt    domain.Statement
        stmts   []domain.Statement
        expr    domain.Expression
        exprs   []domain.Expression
        param   domain.Parameter
        params  []domain.Parameter
        field   domain.StructField
        fields  []domain.StructField
        typ     domain.Type
}

const INT = 57346
const FLOAT = 57347
const STRING = 57348
const BOOL = 57349
const IDENTIFIER = 57350
const FUNC = 57351
const STRUCT = 57352
const VAR = 57353
const IF = 57354
const ELSE = 57355
const WHILE = 57356
const FOR = 57357
const RETURN = 57358
const TRUE = 57359
const FALSE = 57360
const PLUS = 57361
const MINUS = 57362
const STAR = 57363
const SLASH = 57364
const PERCENT = 57365
const EQUAL = 57366
const NOT_EQUAL = 57367
const LESS = 57368
const LESS_EQUAL = 57369
const GREATER = 57370
const GREATER_EQUAL = 57371
const AND = 57372
const OR = 57373
const NOT = 57374
const ASSIGN = 57375
const LEFT_PAREN = 57376
const RIGHT_PAREN = 57377
const LEFT_BRACE = 57378
const RIGHT_BRACE = 57379
const LEFT_BRACKET = 57380
const RIGHT_BRACKET = 57381
const SEMICOLON = 57382
const COMMA = 57383
const DOT = 57384
const COLON = 57385
const ARROW = 57386
const LOWER_THAN_ELSE = 57387
const UNARY_MINUS = 57388

var yyToknames = [...]string{
        "$end",
        "error",
        "$unk",
        "INT",
        "FLOAT",
        "STRING",
        "BOOL",
        "IDENTIFIER",
        "FUNC",
        "STRUCT",
        "VAR",
        "IF",
        "ELSE",
        "WHILE",
        "FOR",
        "RETURN",
        "TRUE",
        "FALSE",
        "PLUS",
        "MINUS",
        "STAR",
        "SLASH",
        "PERCENT",
        "EQUAL",
        "NOT_EQUAL",
        "LESS",
        "LESS_EQUAL",
        "GREATER",
        "GREATER_EQUAL",
        "AND",
        "OR",
        "NOT",
        "ASSIGN",
        "LEFT_PAREN",
        "RIGHT_PAREN",
        "LEFT_BRACE",
        "RIGHT_BRACE",
        "LEFT_BRACKET",
        "RIGHT_BRACKET",
        "SEMICOLON",
        "COMMA",
        "DOT",
        "COLON",
        "ARROW",
        "LOWER_THAN_ELSE",
        "UNARY_MINUS",
}

var yyStatenames = [...]string{}

const yyEofCode = 1
const yyErrCode = 2
const yyInitialStackSize = 16

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

// createBinaryExpr creates a binary expression node with proper location tracking
func createBinaryExpr(left domain.Expression, op domain.BinaryOperator, right domain.Expression) *domain.BinaryExpr <span class="cov8" title="1">{
        return &amp;domain.BinaryExpr{
                BaseNode: domain.BaseNode{Location: left.GetLocation()},
                Left:     left,
                Operator: op,
                Right:    right,
        }
}</span>

// getLocationFromToken extracts source location from a token
func getLocationFromToken(token interfaces.Token) domain.SourceRange <span class="cov8" title="1">{
        pos := token.Location
        return domain.SourceRange{
                Start: pos,
                End:   pos,
        }
}</span>

// getLocationFromString creates a placeholder location for string-based nodes
// TODO: Implement proper position tracking for string literals
func getLocationFromString(str string) domain.SourceRange <span class="cov8" title="1">{
        return domain.SourceRange{
                Start: domain.SourcePosition{},
                End:   domain.SourcePosition{},
        }
}</span>

// getLocation determines the source range for a list of declarations
func getLocation(decls []domain.Declaration) domain.SourceRange <span class="cov8" title="1">{
        if len(decls) == 0 </span><span class="cov0" title="0">{
                return domain.SourceRange{}
        }</span>
        <span class="cov8" title="1">start := decls[0].GetLocation()
        end := decls[len(decls)-1].GetLocation()
        return domain.SourceRange{
                Start: start.Start,
                End:   end.End,
        }</span>
}

var yyExca = [...]int8{
        -1, 1,
        1, -1,
        -2, 0,
}

const yyPrivate = 57344

const yyLast = 357

var yyAct = [...]uint8{
        108, 72, 27, 12, 124, 73, 48, 145, 129, 74,
        125, 119, 49, 156, 144, 130, 22, 40, 10, 155,
        10, 117, 154, 21, 146, 14, 15, 16, 143, 85,
        9, 53, 58, 11, 33, 12, 10, 28, 32, 78,
        126, 10, 23, 17, 10, 12, 10, 32, 52, 24,
        10, 34, 81, 12, 47, 35, 53, 51, 77, 54,
        12, 12, 20, 57, 162, 11, 10, 28, 10, 161,
        80, 148, 133, 83, 55, 12, 7, 8, 18, 79,
        132, 82, 30, 147, 101, 102, 104, 26, 131, 53,
        19, 11, 103, 75, 76, 31, 10, 50, 61, 62,
        63, 106, 157, 12, 107, 11, 29, 3, 25, 105,
        13, 86, 87, 88, 89, 90, 91, 92, 93, 94,
        95, 96, 97, 98, 99, 56, 36, 127, 59, 60,
        61, 62, 63, 39, 141, 135, 128, 136, 84, 116,
        115, 138, 114, 139, 140, 113, 10, 112, 152, 153,
        111, 110, 2, 149, 150, 158, 159, 151, 160, 137,
        6, 5, 163, 164, 41, 42, 43, 4, 12, 1,
        0, 118, 120, 0, 121, 122, 123, 44, 45, 0,
        37, 59, 60, 61, 62, 63, 64, 65, 66, 67,
        68, 69, 38, 0, 46, 0, 53, 41, 42, 43,
        142, 12, 0, 0, 118, 120, 0, 121, 122, 123,
        44, 45, 0, 37, 59, 60, 61, 62, 63, 0,
        0, 66, 67, 68, 69, 38, 0, 46, 0, 53,
        109, 41, 42, 43, 0, 12, 0, 0, 118, 120,
        0, 121, 122, 123, 44, 45, 0, 37, 0, 0,
        0, 41, 42, 43, 0, 12, 0, 0, 0, 38,
        0, 46, 0, 53, 44, 45, 0, 37, 0, 41,
        42, 43, 0, 12, 0, 0, 0, 0, 0, 38,
        0, 46, 44, 45, 0, 37, 0, 134, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 38, 0, 46,
        100, 59, 60, 61, 62, 63, 64, 65, 66, 67,
        68, 69, 70, 71, 41, 42, 43, 0, 12, 0,
        0, 0, 0, 0, 0, 0, 0, 44, 45, 0,
        37, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 38, 0, 46, 59, 60, 61, 62, 63,
        64, 65, 66, 67, 68, 69, 70,
}

var yyPact = [...]int16{
        67, -1000, 67, -1000, -1000, -1000, -1000, 95, 95, 95,
        -1000, 39, -1000, -1000, 56, 26, -17, 3, 27, 52,
        45, -1000, 310, 27, -1000, -29, 53, -1000, 27, 37,
        -1000, -1000, 27, -8, 282, -1000, -33, 310, 310, -1000,
        -1000, -1000, -1000, -1000, -1000, -1000, 310, -1000, -5, 95,
        27, 20, -1000, -1000, -1000, -1000, -1000, -11, -1000, 310,
        310, 310, 310, 310, 310, 310, 310, 310, 310, 310,
        310, 310, 265, 310, 95, -1000, -1000, 51, 27, 20,
        -1000, -1000, 20, -1000, 193, -1000, 77, 77, -1000, -1000,
        -1000, 195, 195, 109, 109, 109, 109, 162, 326, -31,
        -1000, -1000, 1, -1000, -1000, 20, -1000, -1000, -1000, -1000,
        -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, 95, -25,
        54, 46, 38, 247, -1000, 310, -1000, -1000, 27, 310,
        -1000, 310, 310, 160, -1000, -12, -1000, -26, -16, 48,
        36, 310, 310, -1000, -1000, 310, -1000, 227, 227, -18,
        -21, -27, 89, -1000, 227, 227, -1000, 227, 34, 29,
        -1000, 227, 227, -1000, -1000,
}

var yyPgo = [...]uint8{
        0, 169, 107, 167, 161, 160, 152, 0, 151, 150,
        147, 145, 142, 140, 139, 21, 138, 11, 133, 126,
        55, 51, 124, 2, 108, 95, 106, 30, 17,
}

var yyR1 = [...]int8{
        0, 1, 1, 6, 6, 2, 2, 2, 5, 5,
        3, 3, 3, 3, 3, 3, 4, 4, 27, 27,
        27, 24, 24, 23, 26, 26, 25, 16, 16, 7,
        7, 7, 7, 7, 7, 7, 7, 8, 8, 9,
        10, 10, 11, 12, 12, 13, 13, 14, 15, 17,
        21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
        21, 21, 21, 21, 20, 20, 20, 19, 19, 19,
        19, 19, 22, 22, 18, 18, 18, 18, 18, 18,
        18, 28,
}

var yyR2 = [...]int8{
        0, 1, 0, 1, 2, 1, 1, 1, 3, 5,
        8, 7, 7, 6, 6, 5, 5, 4, 1, 4,
        3, 1, 3, 2, 1, 2, 3, 0, 2, 1,
        1, 1, 1, 1, 1, 1, 1, 4, 6, 4,
        5, 7, 5, 8, 8, 2, 3, 2, 3, 1,
        1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 1, 2, 2, 1, 4, 3,
        4, 3, 1, 3, 1, 1, 1, 1, 1, 1,
        3, 1,
}

var yyChk = [...]int16{
        -1000, -1, -6, -2, -3, -4, -5, 9, 10, -27,
        -28, 38, 8, -2, -28, -28, -28, 4, 39, 34,
        36, 40, 33, 39, -27, -24, 35, -23, -28, -26,
        37, -25, -28, -17, -21, -20, -19, 20, 32, -18,
        -28, 4, 5, 6, 17, 18, 34, -27, 35, 41,
        44, -27, -15, 36, -27, 37, -25, -27, 40, 19,
        20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
        30, 31, 34, 38, 42, -20, -20, -17, 44, -27,
        -15, -23, -27, -15, -16, 40, -21, -21, -21, -21,
        -21, -21, -21, -21, -21, -21, -21, -21, -21, -22,
        35, -17, -17, -28, 35, -27, -15, -15, -7, 37,
        -8, -9, -10, -11, -12, -13, -14, -15, 11, -17,
        12, 14, 15, 16, 35, 41, 39, -15, -28, 33,
        40, 34, 34, 34, 40, -17, -17, -27, -17, -17,
        -17, -7, 40, 40, 40, 33, 40, 35, 35, -17,
        -17, -17, -7, -7, 40, 40, 40, 13, -7, -7,
        -7, 35, 35, -7, -7,
}

var yyDef = [...]int8{
        2, -2, 1, 3, 5, 6, 7, 0, 0, 0,
        18, 0, 81, 4, 0, 0, 0, 0, 0, 0,
        0, 8, 0, 0, 20, 0, 0, 21, 0, 0,
        17, 24, 0, 0, 49, 50, 64, 0, 0, 67,
        74, 75, 76, 77, 78, 79, 0, 19, 0, 0,
        0, 0, 15, 27, 23, 16, 25, 0, 9, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 65, 66, 0, 0, 0,
        14, 22, 0, 13, 0, 26, 51, 52, 53, 54,
        55, 56, 57, 58, 59, 60, 61, 62, 63, 0,
        69, 72, 0, 71, 80, 0, 12, 11, 28, 48,
        29, 30, 31, 32, 33, 34, 35, 36, 0, 0,
        0, 0, 0, 0, 68, 0, 70, 10, 0, 0,
        47, 0, 0, 0, 45, 0, 73, 0, 0, 0,
        0, 0, 0, 46, 37, 0, 39, 0, 0, 0,
        0, 0, 40, 42, 0, 0, 38, 0, 0, 0,
        41, 0, 0, 43, 44,
}

var yyTok1 = [...]int8{
        1,
}

var yyTok2 = [...]int8{
        2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
        12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
        22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
        32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
        42, 43, 44, 45, 46,
}

var yyTok3 = [...]int8{
        0,
}

var yyErrorMessages = [...]struct {
        state int
        token int
        msg   string
}{}

/*        parser for yacc output        */

var (
        yyDebug        = 0
        yyErrorVerbose = false
)

type yyLexer interface {
        Lex(lval *yySymType) int
        Error(s string)
}

type yyParser interface {
        Parse(yyLexer) int
        Lookahead() int
}

type yyParserImpl struct {
        lval  yySymType
        stack [yyInitialStackSize]yySymType
        char  int
}

func (p *yyParserImpl) Lookahead() int <span class="cov0" title="0">{
        return p.char
}</span>

func yyNewParser() yyParser <span class="cov8" title="1">{
        return &amp;yyParserImpl{}
}</span>

const yyFlag = -1000

func yyTokname(c int) string <span class="cov8" title="1">{
        if c &gt;= 1 &amp;&amp; c-1 &lt; len(yyToknames) </span><span class="cov8" title="1">{
                if yyToknames[c-1] != "" </span><span class="cov8" title="1">{
                        return yyToknames[c-1]
                }</span>
        }
        <span class="cov0" title="0">return __yyfmt__.Sprintf("tok-%v", c)</span>
}

func yyStatname(s int) string <span class="cov8" title="1">{
        if s &gt;= 0 &amp;&amp; s &lt; len(yyStatenames) </span><span class="cov0" title="0">{
                if yyStatenames[s] != "" </span><span class="cov0" title="0">{
                        return yyStatenames[s]
                }</span>
        }
        <span class="cov8" title="1">return __yyfmt__.Sprintf("state-%v", s)</span>
}

func yyErrorMessage(state, lookAhead int) string <span class="cov8" title="1">{
        const TOKSTART = 4

        if !yyErrorVerbose </span><span class="cov8" title="1">{
                return "syntax error"
        }</span>

        <span class="cov0" title="0">for _, e := range yyErrorMessages </span><span class="cov0" title="0">{
                if e.state == state &amp;&amp; e.token == lookAhead </span><span class="cov0" title="0">{
                        return "syntax error: " + e.msg
                }</span>
        }

        <span class="cov0" title="0">res := "syntax error: unexpected " + yyTokname(lookAhead)

        // To match Bison, suggest at most four expected tokens.
        expected := make([]int, 0, 4)

        // Look for shiftable tokens.
        base := int(yyPact[state])
        for tok := TOKSTART; tok-1 &lt; len(yyToknames); tok++ </span><span class="cov0" title="0">{
                if n := base + tok; n &gt;= 0 &amp;&amp; n &lt; yyLast &amp;&amp; int(yyChk[int(yyAct[n])]) == tok </span><span class="cov0" title="0">{
                        if len(expected) == cap(expected) </span><span class="cov0" title="0">{
                                return res
                        }</span>
                        <span class="cov0" title="0">expected = append(expected, tok)</span>
                }
        }

        <span class="cov0" title="0">if yyDef[state] == -2 </span><span class="cov0" title="0">{
                i := 0
                for yyExca[i] != -1 || int(yyExca[i+1]) != state </span><span class="cov0" title="0">{
                        i += 2
                }</span>

                // Look for tokens that we accept or reduce.
                <span class="cov0" title="0">for i += 2; yyExca[i] &gt;= 0; i += 2 </span><span class="cov0" title="0">{
                        tok := int(yyExca[i])
                        if tok &lt; TOKSTART || yyExca[i+1] == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if len(expected) == cap(expected) </span><span class="cov0" title="0">{
                                return res
                        }</span>
                        <span class="cov0" title="0">expected = append(expected, tok)</span>
                }

                // If the default action is to accept or reduce, give up.
                <span class="cov0" title="0">if yyExca[i+1] != 0 </span><span class="cov0" title="0">{
                        return res
                }</span>
        }

        <span class="cov0" title="0">for i, tok := range expected </span><span class="cov0" title="0">{
                if i == 0 </span><span class="cov0" title="0">{
                        res += ", expecting "
                }</span> else<span class="cov0" title="0"> {
                        res += " or "
                }</span>
                <span class="cov0" title="0">res += yyTokname(tok)</span>
        }
        <span class="cov0" title="0">return res</span>
}

func yylex1(lex yyLexer, lval *yySymType) (char, token int) <span class="cov8" title="1">{
        token = 0
        char = lex.Lex(lval)
        if char &lt;= 0 </span><span class="cov8" title="1">{
                token = int(yyTok1[0])
                goto out</span>
        }
        <span class="cov8" title="1">if char &lt; len(yyTok1) </span><span class="cov0" title="0">{
                token = int(yyTok1[char])
                goto out</span>
        }
        <span class="cov8" title="1">if char &gt;= yyPrivate </span><span class="cov8" title="1">{
                if char &lt; yyPrivate+len(yyTok2) </span><span class="cov8" title="1">{
                        token = int(yyTok2[char-yyPrivate])
                        goto out</span>
                }
        }
        <span class="cov0" title="0">for i := 0; i &lt; len(yyTok3); i += 2 </span><span class="cov0" title="0">{
                token = int(yyTok3[i+0])
                if token == char </span><span class="cov0" title="0">{
                        token = int(yyTok3[i+1])
                        goto out</span>
                }
        }

out:
        <span class="cov8" title="1">if token == 0 </span><span class="cov0" title="0">{
                token = int(yyTok2[1]) /* unknown char */
        }</span>
        <span class="cov8" title="1">if yyDebug &gt;= 3 </span><span class="cov8" title="1">{
                __yyfmt__.Printf("lex %s(%d)\n", yyTokname(token), uint(char))
        }</span>
        <span class="cov8" title="1">return char, token</span>
}

func yyParse(yylex yyLexer) int <span class="cov8" title="1">{
        return yyNewParser().Parse(yylex)
}</span>

func (yyrcvr *yyParserImpl) Parse(yylex yyLexer) int <span class="cov8" title="1">{
        var yyn int
        var yyVAL yySymType
        var yyDollar []yySymType
        _ = yyDollar // silence set and not used
        yyS := yyrcvr.stack[:]

        Nerrs := 0   /* number of errors */
        Errflag := 0 /* error recovery flag */
        yystate := 0
        yyrcvr.char = -1
        yytoken := -1 // yyrcvr.char translated into internal numbering
        defer func() </span><span class="cov8" title="1">{
                // Make sure we report no lookahead when not parsing.
                yystate = -1
                yyrcvr.char = -1
                yytoken = -1
        }</span>()
        <span class="cov8" title="1">yyp := -1
        goto yystack</span>

ret0:
        <span class="cov8" title="1">return 0

</span>ret1:
        <span class="cov8" title="1">return 1

</span>yystack:
        /* put a state and value onto the stack */
        <span class="cov8" title="1">if yyDebug &gt;= 4 </span><span class="cov0" title="0">{
                __yyfmt__.Printf("char %v in %v\n", yyTokname(yytoken), yyStatname(yystate))
        }</span>

        <span class="cov8" title="1">yyp++
        if yyp &gt;= len(yyS) </span><span class="cov8" title="1">{
                nyys := make([]yySymType, len(yyS)*2)
                copy(nyys, yyS)
                yyS = nyys
        }</span>
        <span class="cov8" title="1">yyS[yyp] = yyVAL
        yyS[yyp].yys = yystate

</span>yynewstate:
        <span class="cov8" title="1">yyn = int(yyPact[yystate])
        if yyn &lt;= yyFlag </span><span class="cov8" title="1">{
                goto yydefault</span> /* simple state */
        }
        <span class="cov8" title="1">if yyrcvr.char &lt; 0 </span><span class="cov8" title="1">{
                yyrcvr.char, yytoken = yylex1(yylex, &amp;yyrcvr.lval)
        }</span>
        <span class="cov8" title="1">yyn += yytoken
        if yyn &lt; 0 || yyn &gt;= yyLast </span><span class="cov8" title="1">{
                goto yydefault</span>
        }
        <span class="cov8" title="1">yyn = int(yyAct[yyn])
        if int(yyChk[yyn]) == yytoken </span><span class="cov8" title="1">{ /* valid shift */
                yyrcvr.char = -1
                yytoken = -1
                yyVAL = yyrcvr.lval
                yystate = yyn
                if Errflag &gt; 0 </span><span class="cov0" title="0">{
                        Errflag--
                }</span>
                <span class="cov8" title="1">goto yystack</span>
        }

yydefault:
        /* default state action */
        <span class="cov8" title="1">yyn = int(yyDef[yystate])
        if yyn == -2 </span><span class="cov8" title="1">{
                if yyrcvr.char &lt; 0 </span><span class="cov0" title="0">{
                        yyrcvr.char, yytoken = yylex1(yylex, &amp;yyrcvr.lval)
                }</span>

                /* look through exception table */
                <span class="cov8" title="1">xi := 0
                for </span><span class="cov8" title="1">{
                        if yyExca[xi+0] == -1 &amp;&amp; int(yyExca[xi+1]) == yystate </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">xi += 2</span>
                }
                <span class="cov8" title="1">for xi += 2; ; xi += 2 </span><span class="cov8" title="1">{
                        yyn = int(yyExca[xi+0])
                        if yyn &lt; 0 || yyn == yytoken </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">yyn = int(yyExca[xi+1])
                if yyn &lt; 0 </span><span class="cov8" title="1">{
                        goto ret0</span>
                }
        }
        <span class="cov8" title="1">if yyn == 0 </span><span class="cov8" title="1">{
                /* error ... attempt to resume parsing */
                switch Errflag </span>{
                case 0:<span class="cov8" title="1"> /* brand new error */
                        yylex.Error(yyErrorMessage(yystate, yytoken))
                        Nerrs++
                        if yyDebug &gt;= 1 </span><span class="cov8" title="1">{
                                __yyfmt__.Printf("%s", yyStatname(yystate))
                                __yyfmt__.Printf(" saw %s\n", yyTokname(yytoken))
                        }</span>
                        <span class="cov8" title="1">fallthrough</span>

                case 1, 2:<span class="cov8" title="1"> /* incompletely recovered error ... try again */
                        Errflag = 3

                        /* find a state where "error" is a legal shift action */
                        for yyp &gt;= 0 </span><span class="cov8" title="1">{
                                yyn = int(yyPact[yyS[yyp].yys]) + yyErrCode
                                if yyn &gt;= 0 &amp;&amp; yyn &lt; yyLast </span><span class="cov8" title="1">{
                                        yystate = int(yyAct[yyn]) /* simulate a shift of "error" */
                                        if int(yyChk[yystate]) == yyErrCode </span><span class="cov0" title="0">{
                                                goto yystack</span>
                                        }
                                }

                                /* the current p has no shift on "error", pop stack */
                                <span class="cov8" title="1">if yyDebug &gt;= 2 </span><span class="cov8" title="1">{
                                        __yyfmt__.Printf("error recovery pops state %d\n", yyS[yyp].yys)
                                }</span>
                                <span class="cov8" title="1">yyp--</span>
                        }
                        /* there is no state on the stack with an error shift ... abort */
                        <span class="cov8" title="1">goto ret1</span>

                case 3:<span class="cov0" title="0"> /* no shift yet; clobber input char */
                        if yyDebug &gt;= 2 </span><span class="cov0" title="0">{
                                __yyfmt__.Printf("error recovery discards %s\n", yyTokname(yytoken))
                        }</span>
                        <span class="cov0" title="0">if yytoken == yyEofCode </span><span class="cov0" title="0">{
                                goto ret1</span>
                        }
                        <span class="cov0" title="0">yyrcvr.char = -1
                        yytoken = -1
                        goto yynewstate</span> /* try again in the same state */
                }
        }

        /* reduction by production yyn */
        <span class="cov8" title="1">if yyDebug &gt;= 2 </span><span class="cov8" title="1">{
                __yyfmt__.Printf("reduce %v in:\n\t%v\n", yyn, yyStatname(yystate))
        }</span>

        <span class="cov8" title="1">yynt := yyn
        yypt := yyp
        _ = yypt // guard against "declared and not used"

        yyp -= int(yyR2[yyn])
        // yyp is now the index of $0. Perform the default action. Iff the
        // reduced production is ε, $1 is possibly out of range.
        if yyp+1 &gt;= len(yyS) </span><span class="cov0" title="0">{
                nyys := make([]yySymType, len(yyS)*2)
                copy(nyys, yyS)
                yyS = nyys
        }</span>
        <span class="cov8" title="1">yyVAL = yyS[yyp+1]

        /* consult goto table to find next state */
        yyn = int(yyR1[yyn])
        yyg := int(yyPgo[yyn])
        yyj := yyg + yyS[yyp].yys + 1

        if yyj &gt;= yyLast </span><span class="cov0" title="0">{
                yystate = int(yyAct[yyg])
        }</span> else<span class="cov8" title="1"> {
                yystate = int(yyAct[yyj])
                if int(yyChk[yystate]) != -yyn </span><span class="cov8" title="1">{
                        yystate = int(yyAct[yyg])
                }</span>
        }
        // dummy call; replaced with literal code
        <span class="cov8" title="1">switch yynt </span>{

        case 1:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        ret := &amp;domain.Program{
                                BaseNode:     domain.BaseNode{Location: getLocation(yyDollar[1].decls)},
                                Declarations: yyDollar[1].decls,
                        }
                        yylex.(*Parser).result = ret
                        yyVAL.program = ret
                }</span>
        case 2:<span class="cov8" title="1">
                yyDollar = yyS[yypt-0 : yypt+1]
                </span><span class="cov8" title="1">{
                        ret := &amp;domain.Program{
                                BaseNode:     domain.BaseNode{},
                                Declarations: []domain.Declaration{},
                        }
                        yylex.(*Parser).result = ret
                        yyVAL.program = ret
                }</span>
        case 3:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.decls = []domain.Declaration{yyDollar[1].decl}
                }</span>
        case 4:<span class="cov0" title="0">
                yyDollar = yyS[yypt-2 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.decls = append(yyDollar[1].decls, yyDollar[2].decl)
                }</span>
        case 5:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.decl = yyDollar[1].decl
                }</span>
        case 6:<span class="cov0" title="0">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.decl = yyDollar[1].decl
                }</span>
        case 7:<span class="cov0" title="0">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.decl = yyDollar[1].decl
                }</span>
        case 8:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.decl = &amp;domain.VarDeclStmt{
                                BaseNode:    domain.BaseNode{Location: getLocationFromToken(yyDollar[2].token)},
                                Name:        yyDollar[2].token.Value,
                                Type_:       yyDollar[1].typ,
                                Initializer: nil,
                        }
                }</span>
        case 9:<span class="cov0" title="0">
                yyDollar = yyS[yypt-5 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.decl = &amp;domain.VarDeclStmt{
                                BaseNode:    domain.BaseNode{Location: getLocationFromToken(yyDollar[2].token)},
                                Name:        yyDollar[2].token.Value,
                                Type_:       yyDollar[1].typ,
                                Initializer: yyDollar[4].expr,
                        }
                }</span>
        case 10:<span class="cov0" title="0">
                yyDollar = yyS[yypt-8 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.decl = &amp;domain.FunctionDecl{
                                BaseNode:   domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Name:       yyDollar[2].token.Value,
                                Parameters: yyDollar[4].params,
                                ReturnType: yyDollar[7].typ,
                                Body:       yyDollar[8].stmt.(*domain.BlockStmt),
                        }
                }</span>
        case 11:<span class="cov8" title="1">
                yyDollar = yyS[yypt-7 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.decl = &amp;domain.FunctionDecl{
                                BaseNode:   domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Name:       yyDollar[2].token.Value,
                                Parameters: []domain.Parameter{},
                                ReturnType: yyDollar[6].typ,
                                Body:       yyDollar[7].stmt.(*domain.BlockStmt),
                        }
                }</span>
        case 12:<span class="cov0" title="0">
                yyDollar = yyS[yypt-7 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.decl = &amp;domain.FunctionDecl{
                                BaseNode:   domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Name:       yyDollar[2].token.Value,
                                Parameters: yyDollar[4].params,
                                ReturnType: yyDollar[6].typ,
                                Body:       yyDollar[7].stmt.(*domain.BlockStmt),
                        }
                }</span>
        case 13:<span class="cov0" title="0">
                yyDollar = yyS[yypt-6 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.decl = &amp;domain.FunctionDecl{
                                BaseNode:   domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Name:       yyDollar[2].token.Value,
                                Parameters: []domain.Parameter{},
                                ReturnType: yyDollar[5].typ,
                                Body:       yyDollar[6].stmt.(*domain.BlockStmt),
                        }
                }</span>
        case 14:<span class="cov0" title="0">
                yyDollar = yyS[yypt-6 : yypt+1]
                </span><span class="cov0" title="0">{
                        reg := yylex.(*Parser).typeRegistry
                        intType, _ := reg.GetType("int")
                        yyVAL.decl = &amp;domain.FunctionDecl{
                                BaseNode:   domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Name:       yyDollar[2].token.Value,
                                Parameters: yyDollar[4].params,
                                ReturnType: intType,
                                Body:       yyDollar[6].stmt.(*domain.BlockStmt),
                        }
                }</span>
        case 15:<span class="cov0" title="0">
                yyDollar = yyS[yypt-5 : yypt+1]
                </span><span class="cov0" title="0">{
                        reg := yylex.(*Parser).typeRegistry
                        intType, _ := reg.GetType("int")
                        yyVAL.decl = &amp;domain.FunctionDecl{
                                BaseNode:   domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Name:       yyDollar[2].token.Value,
                                Parameters: []domain.Parameter{},
                                ReturnType: intType,
                                Body:       yyDollar[5].stmt.(*domain.BlockStmt),
                        }
                }</span>
        case 16:<span class="cov0" title="0">
                yyDollar = yyS[yypt-5 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.decl = &amp;domain.StructDecl{
                                BaseNode: domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Name:     yyDollar[2].token.Value,
                                Fields:   yyDollar[4].fields,
                        }
                }</span>
        case 17:<span class="cov0" title="0">
                yyDollar = yyS[yypt-4 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.decl = &amp;domain.StructDecl{
                                BaseNode: domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Name:     yyDollar[2].token.Value,
                                Fields:   []domain.StructField{},
                        }
                }</span>
        case 18:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        reg := yylex.(*Parser).typeRegistry
                        if t, exists := reg.GetType(yyDollar[1].token.Value); exists </span><span class="cov8" title="1">{
                                yyVAL.typ = t
                        }</span> else<span class="cov0" title="0"> {
                                yyVAL.typ = &amp;domain.TypeError{Message: fmt.Sprintf("unknown type: %s", yyDollar[1].token.Value)}
                        }</span>
                }
        case 19:<span class="cov0" title="0">
                yyDollar = yyS[yypt-4 : yypt+1]
                </span><span class="cov0" title="0">{
                        size, _ := strconv.ParseInt(yyDollar[2].token.Value, 10, 32)
                        yyVAL.typ = &amp;domain.ArrayType{
                                ElementType: yyDollar[4].typ,
                                Size:        int(size),
                        }
                }</span>
        case 20:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.typ = &amp;domain.ArrayType{
                                ElementType: yyDollar[3].typ,
                                Size:        -1, // -1 indicates dynamic array
                        }
                }</span>
        case 21:<span class="cov0" title="0">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.params = []domain.Parameter{yyDollar[1].param}
                }</span>
        case 22:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.params = append(yyDollar[1].params, yyDollar[3].param)
                }</span>
        case 23:<span class="cov0" title="0">
                yyDollar = yyS[yypt-2 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.param = domain.Parameter{
                                Name: yyDollar[1].token.Value,
                                Type: yyDollar[2].typ,
                        }
                }</span>
        case 24:<span class="cov0" title="0">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.fields = []domain.StructField{yyDollar[1].field}
                }</span>
        case 25:<span class="cov0" title="0">
                yyDollar = yyS[yypt-2 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.fields = append(yyDollar[1].fields, yyDollar[2].field)
                }</span>
        case 26:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.field = domain.StructField{
                                Name: yyDollar[1].token.Value,
                                Type: yyDollar[2].typ,
                        }
                }</span>
        case 27:<span class="cov8" title="1">
                yyDollar = yyS[yypt-0 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmts = []domain.Statement{}
                }</span>
        case 28:<span class="cov8" title="1">
                yyDollar = yyS[yypt-2 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmts = append(yyDollar[1].stmts, yyDollar[2].stmt)
                }</span>
        case 29:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmt = yyDollar[1].stmt
                }</span>
        case 30:<span class="cov0" title="0">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.stmt = yyDollar[1].stmt
                }</span>
        case 31:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmt = yyDollar[1].stmt
                }</span>
        case 32:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmt = yyDollar[1].stmt
                }</span>
        case 33:<span class="cov0" title="0">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.stmt = yyDollar[1].stmt
                }</span>
        case 34:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmt = yyDollar[1].stmt
                }</span>
        case 35:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmt = yyDollar[1].stmt
                }</span>
        case 36:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmt = yyDollar[1].stmt
                }</span>
        case 37:<span class="cov0" title="0">
                yyDollar = yyS[yypt-4 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.stmt = &amp;domain.VarDeclStmt{
                                BaseNode:    domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Name:        yyDollar[2].token.Value,
                                Type_:       yyDollar[3].typ,
                                Initializer: nil,
                        }
                }</span>
        case 38:<span class="cov8" title="1">
                yyDollar = yyS[yypt-6 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmt = &amp;domain.VarDeclStmt{
                                BaseNode:    domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Name:        yyDollar[2].token.Value,
                                Type_:       yyDollar[3].typ,
                                Initializer: yyDollar[5].expr,
                        }
                }</span>
        case 39:<span class="cov0" title="0">
                yyDollar = yyS[yypt-4 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.stmt = &amp;domain.AssignStmt{
                                BaseNode: domain.BaseNode{Location: yyDollar[1].expr.GetLocation()},
                                Target:   yyDollar[1].expr,
                                Value:    yyDollar[3].expr,
                        }
                }</span>
        case 40:<span class="cov8" title="1">
                yyDollar = yyS[yypt-5 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmt = &amp;domain.IfStmt{
                                BaseNode:  domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Condition: yyDollar[3].expr,
                                ThenStmt:  yyDollar[5].stmt,
                                ElseStmt:  nil,
                        }
                }</span>
        case 41:<span class="cov8" title="1">
                yyDollar = yyS[yypt-7 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmt = &amp;domain.IfStmt{
                                BaseNode:  domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Condition: yyDollar[3].expr,
                                ThenStmt:  yyDollar[5].stmt,
                                ElseStmt:  yyDollar[7].stmt,
                        }
                }</span>
        case 42:<span class="cov8" title="1">
                yyDollar = yyS[yypt-5 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmt = &amp;domain.WhileStmt{
                                BaseNode:  domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Condition: yyDollar[3].expr,
                                Body:      yyDollar[5].stmt,
                        }
                }</span>
        case 43:<span class="cov0" title="0">
                yyDollar = yyS[yypt-8 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.stmt = &amp;domain.ForStmt{
                                BaseNode:  domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Init:      yyDollar[3].stmt,
                                Condition: yyDollar[4].expr,
                                Update:    yyDollar[6].stmt,
                                Body:      yyDollar[8].stmt,
                        }
                }</span>
        case 44:<span class="cov0" title="0">
                yyDollar = yyS[yypt-8 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.stmt = &amp;domain.ForStmt{
                                BaseNode:  domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Init:      nil,
                                Condition: yyDollar[4].expr,
                                Update:    yyDollar[6].stmt,
                                Body:      yyDollar[8].stmt,
                        }
                }</span>
        case 45:<span class="cov8" title="1">
                yyDollar = yyS[yypt-2 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmt = &amp;domain.ReturnStmt{
                                BaseNode: domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Value:    nil,
                        }
                }</span>
        case 46:<span class="cov8" title="1">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmt = &amp;domain.ReturnStmt{
                                BaseNode: domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Value:    yyDollar[2].expr,
                        }
                }</span>
        case 47:<span class="cov8" title="1">
                yyDollar = yyS[yypt-2 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmt = &amp;domain.ExprStmt{
                                BaseNode:   domain.BaseNode{Location: yyDollar[1].expr.GetLocation()},
                                Expression: yyDollar[1].expr,
                        }
                }</span>
        case 48:<span class="cov8" title="1">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.stmt = &amp;domain.BlockStmt{
                                BaseNode:   domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Statements: yyDollar[2].stmts,
                        }
                }</span>
        case 49:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.expr = yyDollar[1].expr
                }</span>
        case 50:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.expr = yyDollar[1].expr
                }</span>
        case 51:<span class="cov8" title="1">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.expr = createBinaryExpr(yyDollar[1].expr, domain.Add, yyDollar[3].expr)
                }</span>
        case 52:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = createBinaryExpr(yyDollar[1].expr, domain.Sub, yyDollar[3].expr)
                }</span>
        case 53:<span class="cov8" title="1">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.expr = createBinaryExpr(yyDollar[1].expr, domain.Mul, yyDollar[3].expr)
                }</span>
        case 54:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = createBinaryExpr(yyDollar[1].expr, domain.Div, yyDollar[3].expr)
                }</span>
        case 55:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = createBinaryExpr(yyDollar[1].expr, domain.Mod, yyDollar[3].expr)
                }</span>
        case 56:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = createBinaryExpr(yyDollar[1].expr, domain.Eq, yyDollar[3].expr)
                }</span>
        case 57:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = createBinaryExpr(yyDollar[1].expr, domain.Ne, yyDollar[3].expr)
                }</span>
        case 58:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = createBinaryExpr(yyDollar[1].expr, domain.Lt, yyDollar[3].expr)
                }</span>
        case 59:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = createBinaryExpr(yyDollar[1].expr, domain.Le, yyDollar[3].expr)
                }</span>
        case 60:<span class="cov8" title="1">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.expr = createBinaryExpr(yyDollar[1].expr, domain.Gt, yyDollar[3].expr)
                }</span>
        case 61:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = createBinaryExpr(yyDollar[1].expr, domain.Ge, yyDollar[3].expr)
                }</span>
        case 62:<span class="cov8" title="1">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.expr = createBinaryExpr(yyDollar[1].expr, domain.And, yyDollar[3].expr)
                }</span>
        case 63:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = createBinaryExpr(yyDollar[1].expr, domain.Or, yyDollar[3].expr)
                }</span>
        case 64:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.expr = yyDollar[1].expr
                }</span>
        case 65:<span class="cov0" title="0">
                yyDollar = yyS[yypt-2 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = &amp;domain.UnaryExpr{
                                BaseNode: domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Operator: domain.Neg,
                                Operand:  yyDollar[2].expr,
                        }
                }</span>
        case 66:<span class="cov0" title="0">
                yyDollar = yyS[yypt-2 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = &amp;domain.UnaryExpr{
                                BaseNode: domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Operator: domain.Not,
                                Operand:  yyDollar[2].expr,
                        }
                }</span>
        case 67:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.expr = yyDollar[1].expr
                }</span>
        case 68:<span class="cov0" title="0">
                yyDollar = yyS[yypt-4 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = &amp;domain.CallExpr{
                                BaseNode: domain.BaseNode{Location: yyDollar[1].expr.GetLocation()},
                                Function: yyDollar[1].expr,
                                Args:     yyDollar[3].exprs,
                        }
                }</span>
        case 69:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = &amp;domain.CallExpr{
                                BaseNode: domain.BaseNode{Location: yyDollar[1].expr.GetLocation()},
                                Function: yyDollar[1].expr,
                                Args:     []domain.Expression{},
                        }
                }</span>
        case 70:<span class="cov0" title="0">
                yyDollar = yyS[yypt-4 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = &amp;domain.IndexExpr{
                                BaseNode: domain.BaseNode{Location: yyDollar[1].expr.GetLocation()},
                                Object:   yyDollar[1].expr,
                                Index:    yyDollar[3].expr,
                        }
                }</span>
        case 71:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = &amp;domain.MemberExpr{
                                BaseNode: domain.BaseNode{Location: yyDollar[1].expr.GetLocation()},
                                Object:   yyDollar[1].expr,
                                Member:   yyDollar[3].token.Value,
                        }
                }</span>
        case 72:<span class="cov0" title="0">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.exprs = []domain.Expression{yyDollar[1].expr}
                }</span>
        case 73:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.exprs = append(yyDollar[1].exprs, yyDollar[3].expr)
                }</span>
        case 74:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.expr = &amp;domain.IdentifierExpr{
                                BaseNode: domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Name:     yyDollar[1].token.Value,
                        }
                }</span>
        case 75:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        val, _ := strconv.ParseInt(yyDollar[1].token.Value, 10, 64)
                        yyVAL.expr = &amp;domain.LiteralExpr{
                                BaseNode: domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Value:    val,
                        }
                }</span>
        case 76:<span class="cov0" title="0">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov0" title="0">{
                        val, _ := strconv.ParseFloat(yyDollar[1].token.Value, 64)
                        yyVAL.expr = &amp;domain.LiteralExpr{
                                BaseNode: domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Value:    val,
                        }
                }</span>
        case 77:<span class="cov0" title="0">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = &amp;domain.LiteralExpr{
                                BaseNode: domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Value:    yyDollar[1].token.Value,
                        }
                }</span>
        case 78:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.expr = &amp;domain.LiteralExpr{
                                BaseNode: domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Value:    true,
                        }
                }</span>
        case 79:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.expr = &amp;domain.LiteralExpr{
                                BaseNode: domain.BaseNode{Location: getLocationFromToken(yyDollar[1].token)},
                                Value:    false,
                        }
                }</span>
        case 80:<span class="cov0" title="0">
                yyDollar = yyS[yypt-3 : yypt+1]
                </span><span class="cov0" title="0">{
                        yyVAL.expr = yyDollar[2].expr
                }</span>
        case 81:<span class="cov8" title="1">
                yyDollar = yyS[yypt-1 : yypt+1]
                </span><span class="cov8" title="1">{
                        yyVAL.token = yyDollar[1].token
                }</span>
        }
        <span class="cov8" title="1">goto yystack</span> /* stack new state and value */
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package grammar

import (
        "fmt"

        "github.com/sokoide/llvm5/internal/domain"
        "github.com/sokoide/llvm5/internal/interfaces"
)

// Parser is a wrapper used by the generated Yacc parser. It adapts the
// project's Lexer (interfaces.Lexer) to the lexer interface expected by the
// generated parser and stores the parse result and a type registry.
type Parser struct {
        lexer        interfaces.Lexer
        result       *domain.Program
        typeRegistry domain.TypeRegistry
        errors       []string
}

// SetDebugLevel sets the parser debug level (0-4)
func SetDebugLevel(level int) <span class="cov8" title="1">{
        if level &gt;= 0 &amp;&amp; level &lt;= 4 </span><span class="cov8" title="1">{
                yyDebug = level
        }</span>
}

// NewRecursiveDescentParser returns a new Parser that implements
// interfaces.Parser. The name matches the factory usage in the codebase.
func NewRecursiveDescentParser() interfaces.Parser <span class="cov8" title="1">{
        return &amp;Parser{}
}</span>

// Parse runs the generated parser against the provided lexer and returns
// the resulting AST program or an error.
func (p *Parser) Parse(lex interfaces.Lexer) (*domain.Program, error) <span class="cov8" title="1">{
        p.lexer = lex
        p.typeRegistry = domain.NewDefaultTypeRegistry()
        p.errors = nil

        rc := yyParse(p)
        if rc != 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("parse error: %v", p.errors)
        }</span>

        <span class="cov8" title="1">if p.result == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no AST produced")
        }</span>
        <span class="cov8" title="1">return p.result, nil</span>
}

// SetErrorReporter satisfies the interfaces.Parser API (no-op for now).
func (p *Parser) SetErrorReporter(reporter domain.ErrorReporter) {<span class="cov8" title="1">
}</span>

// Lex implements the lexer interface expected by the generated parser.
// It pulls tokens from the underlying interfaces.Lexer and maps them to
// the token constants generated in parser.go. It also stores the token
// into the semantic value union so parser actions can access it.
func (p *Parser) Lex(lval *yySymType) int <span class="cov8" title="1">{
        tok := p.lexer.NextToken()
        if tok.Type == interfaces.TokenEOF </span><span class="cov8" title="1">{
                // follow the yacc/goyacc contract, return 0
                return 0
        }</span>
        <span class="cov8" title="1">lval.token = tok

        switch tok.Type </span>{
        case interfaces.TokenInt:<span class="cov8" title="1">
                return INT</span>
        case interfaces.TokenFloat:<span class="cov0" title="0">
                return FLOAT</span>
        case interfaces.TokenString:<span class="cov0" title="0">
                return STRING</span>
        case interfaces.TokenBool:<span class="cov0" title="0">
                return IDENTIFIER</span>
        case interfaces.TokenIdentifier:<span class="cov8" title="1">
                return IDENTIFIER</span>
        case interfaces.TokenFunc:<span class="cov8" title="1">
                return FUNC</span>
        case interfaces.TokenStruct:<span class="cov0" title="0">
                return STRUCT</span>
        case interfaces.TokenVar:<span class="cov8" title="1">
                return VAR</span>
        case interfaces.TokenIf:<span class="cov8" title="1">
                return IF</span>
        case interfaces.TokenElse:<span class="cov8" title="1">
                return ELSE</span>
        case interfaces.TokenWhile:<span class="cov8" title="1">
                return WHILE</span>
        case interfaces.TokenFor:<span class="cov0" title="0">
                return FOR</span>
        case interfaces.TokenReturn:<span class="cov8" title="1">
                return RETURN</span>
        case interfaces.TokenTrue:<span class="cov8" title="1">
                return TRUE</span>
        case interfaces.TokenFalse:<span class="cov8" title="1">
                return FALSE</span>
        case interfaces.TokenPlus:<span class="cov8" title="1">
                return PLUS</span>
        case interfaces.TokenMinus:<span class="cov0" title="0">
                return MINUS</span>
        case interfaces.TokenStar:<span class="cov8" title="1">
                return STAR</span>
        case interfaces.TokenSlash:<span class="cov0" title="0">
                return SLASH</span>
        case interfaces.TokenPercent:<span class="cov0" title="0">
                return PERCENT</span>
        case interfaces.TokenEqual:<span class="cov0" title="0">
                return EQUAL</span>
        case interfaces.TokenNotEqual:<span class="cov0" title="0">
                return NOT_EQUAL</span>
        case interfaces.TokenLess:<span class="cov0" title="0">
                return LESS</span>
        case interfaces.TokenLessEqual:<span class="cov0" title="0">
                return LESS_EQUAL</span>
        case interfaces.TokenGreater:<span class="cov8" title="1">
                return GREATER</span>
        case interfaces.TokenGreaterEqual:<span class="cov0" title="0">
                return GREATER_EQUAL</span>
        case interfaces.TokenAnd:<span class="cov8" title="1">
                return AND</span>
        case interfaces.TokenOr:<span class="cov0" title="0">
                return OR</span>
        case interfaces.TokenNot:<span class="cov0" title="0">
                return NOT</span>
        case interfaces.TokenAssign:<span class="cov8" title="1">
                return ASSIGN</span>
        case interfaces.TokenLeftParen:<span class="cov8" title="1">
                return LEFT_PAREN</span>
        case interfaces.TokenRightParen:<span class="cov8" title="1">
                return RIGHT_PAREN</span>
        case interfaces.TokenLeftBrace:<span class="cov8" title="1">
                return LEFT_BRACE</span>
        case interfaces.TokenRightBrace:<span class="cov8" title="1">
                return RIGHT_BRACE</span>
        case interfaces.TokenLeftBracket:<span class="cov0" title="0">
                return LEFT_BRACKET</span>
        case interfaces.TokenRightBracket:<span class="cov0" title="0">
                return RIGHT_BRACKET</span>
        case interfaces.TokenSemicolon:<span class="cov8" title="1">
                return SEMICOLON</span>
        case interfaces.TokenComma:<span class="cov0" title="0">
                return COMMA</span>
        case interfaces.TokenDot:<span class="cov0" title="0">
                return DOT</span>
        case interfaces.TokenColon:<span class="cov8" title="1">
                return COLON</span>
        case interfaces.TokenArrow:<span class="cov8" title="1">
                return ARROW</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}

// Error records a parse error message.
func (p *Parser) Error(s string) <span class="cov8" title="1">{
        p.errors = append(p.errors, s)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package application contains factory patterns for compiler components
package application

import (
        "fmt"
        "io"
        "os"

        "github.com/sokoide/llvm5/grammar"
        "github.com/sokoide/llvm5/internal/domain"
        "github.com/sokoide/llvm5/internal/infrastructure"
        "github.com/sokoide/llvm5/internal/interfaces"
        "github.com/sokoide/llvm5/lexer"
        "github.com/sokoide/llvm5/semantic"
)

// CompilerConfig holds configuration for the compiler
type CompilerConfig struct {
        // Component configurations
        UseMockComponents bool
        MemoryManagerType MemoryManagerType
        ErrorReporterType ErrorReporterType

        // Compilation options
        CompilationOptions domain.CompilationOptions

        // Output configuration
        ErrorOutput io.Writer
        Verbose     bool
}

// MemoryManagerType specifies the type of memory manager to use
type MemoryManagerType int

const (
        PooledMemoryManager MemoryManagerType = iota
        CompactMemoryManager
        TrackingMemoryManager
)

// ErrorReporterType specifies the type of error reporter to use
type ErrorReporterType int

const (
        ConsoleErrorReporter ErrorReporterType = iota
        SortedErrorReporter
)

// DefaultCompilerConfig returns a default compiler configuration
func DefaultCompilerConfig() CompilerConfig <span class="cov8" title="1">{
        return CompilerConfig{
                UseMockComponents: false,
                MemoryManagerType: PooledMemoryManager,
                ErrorReporterType: ConsoleErrorReporter,
                CompilationOptions: domain.CompilationOptions{
                        OptimizationLevel: 0,
                        DebugInfo:         false,
                        TargetTriple:      "",
                        OutputPath:        "",
                        WarningsAsErrors:  false,
                },
                ErrorOutput: os.Stderr,
                Verbose:     false,
        }
}</span>

// CompilerFactory creates configured compiler components
type CompilerFactory struct {
        config CompilerConfig
}

// NewCompilerFactory creates a new compiler factory with the given configuration
func NewCompilerFactory(config CompilerConfig) *CompilerFactory <span class="cov8" title="1">{
        return &amp;CompilerFactory{
                config: config,
        }
}</span>

// CreateCompilerPipeline creates a fully configured compiler pipeline
func (factory *CompilerFactory) CreateCompilerPipeline() interfaces.CompilerPipeline <span class="cov8" title="1">{
        pipeline := NewDefaultCompilerPipeline()

        // Set up components
        pipeline.SetLexer(factory.CreateLexer())
        pipeline.SetParser(factory.CreateParser())
        pipeline.SetSemanticAnalyzer(factory.CreateSemanticAnalyzer())
        pipeline.SetCodeGenerator(factory.CreateCodeGenerator())
        pipeline.SetErrorReporter(factory.CreateErrorReporter())
        pipeline.SetTypeRegistry(factory.CreateTypeRegistry())
        pipeline.SetSymbolTable(factory.CreateSymbolTable())
        pipeline.SetMemoryManager(factory.CreateMemoryManager())
        pipeline.SetOptions(factory.config.CompilationOptions)

        return pipeline
}</span>

// CreateMultiFileCompilerPipeline creates a multi-file compiler pipeline
func (factory *CompilerFactory) CreateMultiFileCompilerPipeline() *MultiFileCompilerPipeline <span class="cov8" title="1">{
        pipeline := NewMultiFileCompilerPipeline()

        // Set up components
        pipeline.SetLexer(factory.CreateLexer())
        pipeline.SetParser(factory.CreateParser())
        pipeline.SetSemanticAnalyzer(factory.CreateSemanticAnalyzer())
        pipeline.SetCodeGenerator(factory.CreateCodeGenerator())
        pipeline.SetErrorReporter(factory.CreateErrorReporter())
        pipeline.SetTypeRegistry(factory.CreateTypeRegistry())
        pipeline.SetSymbolTable(factory.CreateSymbolTable())
        pipeline.SetMemoryManager(factory.CreateMemoryManager())
        pipeline.SetOptions(factory.config.CompilationOptions)

        return pipeline
}</span>

// CreateLexer creates a lexer component
func (factory *CompilerFactory) CreateLexer() interfaces.Lexer <span class="cov8" title="1">{
        if factory.config.UseMockComponents </span><span class="cov8" title="1">{
                return NewMockLexer()
        }</span>
        // Return the real lexer implementation
        <span class="cov8" title="1">return lexer.NewLexer()</span>
}

// CreateParser creates a parser component
func (factory *CompilerFactory) CreateParser() interfaces.Parser <span class="cov8" title="1">{
        if factory.config.UseMockComponents </span><span class="cov8" title="1">{
                return NewMockParser()
        }</span>
        // Use the recursive descent parser instead of yacc-generated parser
        <span class="cov8" title="1">return grammar.NewRecursiveDescentParser()</span>
}

// CreateSemanticAnalyzer creates a semantic analyzer component
func (factory *CompilerFactory) CreateSemanticAnalyzer() interfaces.SemanticAnalyzer <span class="cov8" title="1">{
        if factory.config.UseMockComponents </span><span class="cov8" title="1">{
                return NewMockSemanticAnalyzer()
        }</span>
        // Return the real semantic analyzer implementation
        <span class="cov8" title="1">return semantic.NewAnalyzer()</span>
}

// CreateCodeGenerator creates a code generator component
func (factory *CompilerFactory) CreateCodeGenerator() interfaces.CodeGenerator <span class="cov8" title="1">{
        if factory.config.UseMockComponents </span><span class="cov8" title="1">{
                return NewMockCodeGenerator()
        }</span>
        // Return the real LLVM IR generator
        <span class="cov8" title="1">return infrastructure.NewRealLLVMIRGenerator()</span>
}

// CreateErrorReporter creates an error reporter
func (factory *CompilerFactory) CreateErrorReporter() domain.ErrorReporter <span class="cov8" title="1">{
        var baseReporter domain.ErrorReporter

        switch factory.config.ErrorReporterType </span>{
        case ConsoleErrorReporter:<span class="cov8" title="1">
                baseReporter = infrastructure.NewConsoleErrorReporter(factory.config.ErrorOutput)</span>
        case SortedErrorReporter:<span class="cov8" title="1">
                consoleReporter := infrastructure.NewConsoleErrorReporter(factory.config.ErrorOutput)
                baseReporter = infrastructure.NewSortedErrorReporter(consoleReporter)</span>
        default:<span class="cov0" title="0">
                baseReporter = infrastructure.NewConsoleErrorReporter(factory.config.ErrorOutput)</span>
        }

        <span class="cov8" title="1">return baseReporter</span>
}

// CreateTypeRegistry creates a type registry
func (factory *CompilerFactory) CreateTypeRegistry() domain.TypeRegistry <span class="cov8" title="1">{
        return domain.NewDefaultTypeRegistry()
}</span>

// CreateSymbolTable creates a symbol table
func (factory *CompilerFactory) CreateSymbolTable() interfaces.SymbolTable <span class="cov8" title="1">{
        return infrastructure.NewDefaultSymbolTable()
}</span>

// CreateMemoryManager creates a memory manager
func (factory *CompilerFactory) CreateMemoryManager() interfaces.MemoryManager <span class="cov8" title="1">{
        var baseManager interfaces.MemoryManager

        switch factory.config.MemoryManagerType </span>{
        case PooledMemoryManager:<span class="cov8" title="1">
                baseManager = infrastructure.NewPooledMemoryManager()</span>
        case CompactMemoryManager:<span class="cov8" title="1">
                baseManager = infrastructure.NewCompactMemoryManager()</span>
        case TrackingMemoryManager:<span class="cov8" title="1">
                pooled := infrastructure.NewPooledMemoryManager()
                baseManager = infrastructure.NewTrackingMemoryManager(pooled)</span>
        default:<span class="cov0" title="0">
                baseManager = infrastructure.NewPooledMemoryManager()</span>
        }

        <span class="cov8" title="1">return baseManager</span>
}

// CreateLLVMBackend creates an LLVM backend
func (factory *CompilerFactory) CreateLLVMBackend() interfaces.LLVMBackend <span class="cov8" title="1">{
        // For now, always return the mock backend
        // In a real implementation, this would create the actual LLVM backend
        return infrastructure.NewMockLLVMBackend()
}</span>

// Mock implementations for development and testing

// MockLexer provides a mock lexer for testing
type MockLexer struct {
        tokens   []interfaces.Token
        position int
}

func NewMockLexer() *MockLexer <span class="cov8" title="1">{
        return &amp;MockLexer{
                tokens:   make([]interfaces.Token, 0),
                position: 0,
        }
}</span>

func (l *MockLexer) NextToken() interfaces.Token <span class="cov8" title="1">{
        if l.position &gt;= len(l.tokens) </span><span class="cov8" title="1">{
                return interfaces.Token{
                        Type:  interfaces.TokenEOF,
                        Value: "",
                        Location: domain.SourcePosition{
                                Filename: "mock",
                                Line:     1,
                                Column:   1,
                        },
                }
        }</span>

        <span class="cov0" title="0">token := l.tokens[l.position]
        l.position++
        return token</span>
}

func (l *MockLexer) Peek() interfaces.Token <span class="cov8" title="1">{
        if l.position &gt;= len(l.tokens) </span><span class="cov8" title="1">{
                return interfaces.Token{Type: interfaces.TokenEOF}
        }</span>
        <span class="cov0" title="0">return l.tokens[l.position]</span>
}

func (l *MockLexer) SetInput(filename string, input io.Reader) error <span class="cov0" title="0">{
        // Mock implementation - in real implementation would read from input
        l.tokens = []interfaces.Token{
                {Type: interfaces.TokenFunc, Value: "func", Location: domain.SourcePosition{Filename: filename, Line: 1, Column: 1}},
                {Type: interfaces.TokenIdentifier, Value: "main", Location: domain.SourcePosition{Filename: filename, Line: 1, Column: 6}},
                {Type: interfaces.TokenLeftParen, Value: "(", Location: domain.SourcePosition{Filename: filename, Line: 1, Column: 10}},
                {Type: interfaces.TokenRightParen, Value: ")", Location: domain.SourcePosition{Filename: filename, Line: 1, Column: 11}},
                {Type: interfaces.TokenLeftBrace, Value: "{", Location: domain.SourcePosition{Filename: filename, Line: 1, Column: 13}},
                {Type: interfaces.TokenRightBrace, Value: "}", Location: domain.SourcePosition{Filename: filename, Line: 1, Column: 14}},
                {Type: interfaces.TokenEOF, Value: "", Location: domain.SourcePosition{Filename: filename, Line: 1, Column: 15}},
        }
        l.position = 0
        return nil
}</span>

func (l *MockLexer) GetCurrentPosition() domain.SourcePosition <span class="cov0" title="0">{
        if l.position &gt;= len(l.tokens) </span><span class="cov0" title="0">{
                return domain.SourcePosition{Filename: "mock", Line: 1, Column: 1}
        }</span>
        <span class="cov0" title="0">return l.tokens[l.position].Location</span>
}

// MockParser provides a mock parser for testing
type MockParser struct {
        errorReporter domain.ErrorReporter
}

func NewMockParser() *MockParser <span class="cov8" title="1">{
        return &amp;MockParser{}
}</span>

func (p *MockParser) Parse(lexer interfaces.Lexer) (*domain.Program, error) <span class="cov8" title="1">{
        // Create a simple mock AST
        program := &amp;domain.Program{
                BaseNode: domain.BaseNode{
                        Location: domain.SourceRange{
                                Start: domain.SourcePosition{Filename: "mock", Line: 1, Column: 1},
                                End:   domain.SourcePosition{Filename: "mock", Line: 1, Column: 15},
                        },
                },
                Declarations: []domain.Declaration{
                        &amp;domain.FunctionDecl{
                                BaseNode: domain.BaseNode{
                                        Location: domain.SourceRange{
                                                Start: domain.SourcePosition{Filename: "mock", Line: 1, Column: 1},
                                                End:   domain.SourcePosition{Filename: "mock", Line: 1, Column: 15},
                                        },
                                },
                                Name:       "main",
                                Parameters: make([]domain.Parameter, 0),
                                ReturnType: &amp;domain.BasicType{Kind: domain.VoidType},
                                Body: &amp;domain.BlockStmt{
                                        BaseNode: domain.BaseNode{
                                                Location: domain.SourceRange{
                                                        Start: domain.SourcePosition{Filename: "mock", Line: 1, Column: 13},
                                                        End:   domain.SourcePosition{Filename: "mock", Line: 1, Column: 14},
                                                },
                                        },
                                        Statements: make([]domain.Statement, 0),
                                },
                        },
                },
        }

        return program, nil
}</span>

func (p *MockParser) SetErrorReporter(reporter domain.ErrorReporter) <span class="cov8" title="1">{
        p.errorReporter = reporter
}</span>

// MockSemanticAnalyzer provides a mock semantic analyzer for testing
type MockSemanticAnalyzer struct {
        typeRegistry  domain.TypeRegistry
        symbolTable   interfaces.SymbolTable
        errorReporter domain.ErrorReporter
}

func NewMockSemanticAnalyzer() *MockSemanticAnalyzer <span class="cov8" title="1">{
        return &amp;MockSemanticAnalyzer{}
}</span>

func (sa *MockSemanticAnalyzer) Analyze(ast *domain.Program) error <span class="cov8" title="1">{
        // Mock semantic analysis - just validate the structure exists
        if ast == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("AST is nil")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (sa *MockSemanticAnalyzer) SetTypeRegistry(registry domain.TypeRegistry) <span class="cov8" title="1">{
        sa.typeRegistry = registry
}</span>

func (sa *MockSemanticAnalyzer) SetSymbolTable(symbolTable interfaces.SymbolTable) <span class="cov8" title="1">{
        sa.symbolTable = symbolTable
}</span>

func (sa *MockSemanticAnalyzer) SetErrorReporter(reporter domain.ErrorReporter) <span class="cov8" title="1">{
        sa.errorReporter = reporter
}</span>

// MockCodeGenerator provides a mock code generator for testing
type MockCodeGenerator struct {
        output        io.Writer
        options       interfaces.CodeGenOptions
        errorReporter domain.ErrorReporter
}

func NewMockCodeGenerator() *MockCodeGenerator <span class="cov8" title="1">{
        return &amp;MockCodeGenerator{}
}</span>

func (cg *MockCodeGenerator) Generate(ast *domain.Program) error <span class="cov8" title="1">{
        if cg.output != nil </span><span class="cov0" title="0">{
                // Write mock output
                _, err := cg.output.Write([]byte("; Mock generated code\n"))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (cg *MockCodeGenerator) SetOutput(output io.Writer) <span class="cov0" title="0">{
        cg.output = output
}</span>

func (cg *MockCodeGenerator) SetOptions(options interfaces.CodeGenOptions) <span class="cov0" title="0">{
        cg.options = options
}</span>

func (cg *MockCodeGenerator) SetErrorReporter(reporter domain.ErrorReporter) <span class="cov8" title="1">{
        cg.errorReporter = reporter
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package application contains the main application logic and pipeline
package application

import (
        "fmt"
        "io"

        "github.com/sokoide/llvm5/internal/domain"
        "github.com/sokoide/llvm5/internal/interfaces"
)

// DefaultCompilerPipeline implements the CompilerPipeline interface
type DefaultCompilerPipeline struct {
        lexer            interfaces.Lexer
        parser           interfaces.Parser
        semanticAnalyzer interfaces.SemanticAnalyzer
        codeGenerator    interfaces.CodeGenerator
        errorReporter    domain.ErrorReporter
        options          domain.CompilationOptions
        typeRegistry     domain.TypeRegistry
        symbolTable      interfaces.SymbolTable
        memoryManager    interfaces.MemoryManager
}

// NewDefaultCompilerPipeline creates a new compiler pipeline with default components
func NewDefaultCompilerPipeline() *DefaultCompilerPipeline <span class="cov8" title="1">{
        return &amp;DefaultCompilerPipeline{
                options: domain.CompilationOptions{
                        OptimizationLevel: 0,
                        DebugInfo:         false,
                        TargetTriple:      "",
                        OutputPath:        "",
                        WarningsAsErrors:  false,
                },
        }
}</span>

// Compile compiles a source file through the entire pipeline
func (cp *DefaultCompilerPipeline) Compile(filename string, input io.Reader, output io.Writer) error <span class="cov0" title="0">{
        // Validate components are set
        if err := cp.validateComponents(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("pipeline validation failed: %w", err)
        }</span>

        // Clear previous errors
        <span class="cov0" title="0">cp.errorReporter.Clear()

        // Phase 1: Lexical Analysis
        if err := cp.lexer.SetInput(filename, input); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set lexer input: %w", err)
        }</span>

        // Phase 2: Syntax Analysis
        <span class="cov0" title="0">ast, err := cp.parser.Parse(cp.lexer)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parsing failed: %w", err)
        }</span>

        // Check for parsing errors
        <span class="cov0" title="0">if cp.errorReporter.HasErrors() </span><span class="cov0" title="0">{
                return fmt.Errorf("compilation failed with %d error(s)", len(cp.errorReporter.GetErrors()))
        }</span>

        // Phase 3: Semantic Analysis
        <span class="cov0" title="0">if err := cp.semanticAnalyzer.Analyze(ast); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("semantic analysis failed: %w", err)
        }</span>

        // Check for semantic errors
        <span class="cov0" title="0">if cp.errorReporter.HasErrors() </span><span class="cov0" title="0">{
                return fmt.Errorf("compilation failed with %d error(s)", len(cp.errorReporter.GetErrors()))
        }</span>

        // Convert warnings to errors if requested
        <span class="cov0" title="0">if cp.options.WarningsAsErrors &amp;&amp; cp.errorReporter.HasWarnings() </span><span class="cov0" title="0">{
                for _, warning := range cp.errorReporter.GetWarnings() </span><span class="cov0" title="0">{
                        warning.Type = domain.TypeCheckError
                        cp.errorReporter.ReportError(warning)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("compilation failed: warnings treated as errors")</span>
        }

        // Phase 4: Code Generation
        <span class="cov0" title="0">cp.codeGenerator.SetOutput(output)
        cp.codeGenerator.SetOptions(interfaces.CodeGenOptions{
                OptimizationLevel: cp.options.OptimizationLevel,
                DebugInfo:         cp.options.DebugInfo,
                TargetTriple:      cp.options.TargetTriple,
        })

        if err := cp.codeGenerator.Generate(ast); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("code generation failed: %w", err)
        }</span>

        // Check for code generation errors
        <span class="cov0" title="0">if cp.errorReporter.HasErrors() </span><span class="cov0" title="0">{
                return fmt.Errorf("compilation failed with %d error(s)", len(cp.errorReporter.GetErrors()))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetLexer sets the lexer implementation
func (cp *DefaultCompilerPipeline) SetLexer(lexer interfaces.Lexer) <span class="cov8" title="1">{
        cp.lexer = lexer
}</span>

// SetParser sets the parser implementation
func (cp *DefaultCompilerPipeline) SetParser(parser interfaces.Parser) <span class="cov8" title="1">{
        cp.parser = parser
        if cp.errorReporter != nil </span><span class="cov0" title="0">{
                parser.SetErrorReporter(cp.errorReporter)
        }</span>
}

// SetSemanticAnalyzer sets the semantic analyzer implementation
func (cp *DefaultCompilerPipeline) SetSemanticAnalyzer(analyzer interfaces.SemanticAnalyzer) <span class="cov8" title="1">{
        cp.semanticAnalyzer = analyzer
        if cp.errorReporter != nil </span><span class="cov0" title="0">{
                analyzer.SetErrorReporter(cp.errorReporter)
        }</span>
        <span class="cov8" title="1">if cp.typeRegistry != nil </span><span class="cov0" title="0">{
                analyzer.SetTypeRegistry(cp.typeRegistry)
        }</span>
        <span class="cov8" title="1">if cp.symbolTable != nil </span><span class="cov0" title="0">{
                analyzer.SetSymbolTable(cp.symbolTable)
        }</span>
}

// SetCodeGenerator sets the code generator implementation
func (cp *DefaultCompilerPipeline) SetCodeGenerator(generator interfaces.CodeGenerator) <span class="cov8" title="1">{
        cp.codeGenerator = generator
        if cp.errorReporter != nil </span><span class="cov0" title="0">{
                generator.SetErrorReporter(cp.errorReporter)
        }</span>
}

// SetErrorReporter sets the error reporter
func (cp *DefaultCompilerPipeline) SetErrorReporter(reporter domain.ErrorReporter) <span class="cov8" title="1">{
        cp.errorReporter = reporter

        // Propagate to components that are already set
        if cp.parser != nil </span><span class="cov8" title="1">{
                cp.parser.SetErrorReporter(reporter)
        }</span>
        <span class="cov8" title="1">if cp.semanticAnalyzer != nil </span><span class="cov8" title="1">{
                cp.semanticAnalyzer.SetErrorReporter(reporter)
        }</span>
        <span class="cov8" title="1">if cp.codeGenerator != nil </span><span class="cov8" title="1">{
                cp.codeGenerator.SetErrorReporter(reporter)
        }</span>
}

// SetOptions sets compilation options
func (cp *DefaultCompilerPipeline) SetOptions(options domain.CompilationOptions) <span class="cov8" title="1">{
        cp.options = options
}</span>

// SetTypeRegistry sets the type registry
func (cp *DefaultCompilerPipeline) SetTypeRegistry(registry domain.TypeRegistry) <span class="cov8" title="1">{
        cp.typeRegistry = registry
        if cp.semanticAnalyzer != nil </span><span class="cov8" title="1">{
                cp.semanticAnalyzer.SetTypeRegistry(registry)
        }</span>
}

// SetSymbolTable sets the symbol table
func (cp *DefaultCompilerPipeline) SetSymbolTable(symbolTable interfaces.SymbolTable) <span class="cov8" title="1">{
        cp.symbolTable = symbolTable
        if cp.semanticAnalyzer != nil </span><span class="cov8" title="1">{
                cp.semanticAnalyzer.SetSymbolTable(symbolTable)
        }</span>
}

// SetMemoryManager sets the memory manager
func (cp *DefaultCompilerPipeline) SetMemoryManager(memoryManager interfaces.MemoryManager) <span class="cov8" title="1">{
        cp.memoryManager = memoryManager
}</span>

// GetStats returns compilation statistics
func (cp *DefaultCompilerPipeline) GetStats() CompilationStats <span class="cov0" title="0">{
        stats := CompilationStats{}

        if cp.errorReporter != nil </span><span class="cov0" title="0">{
                stats.ErrorCount = len(cp.errorReporter.GetErrors())
                stats.WarningCount = len(cp.errorReporter.GetWarnings())
        }</span>

        <span class="cov0" title="0">if cp.memoryManager != nil </span><span class="cov0" title="0">{
                memStats := cp.memoryManager.GetStats()
                stats.MemoryUsage = memStats.TotalMemoryUsed
                stats.NodesCreated = memStats.NodesAllocated
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// CompilationStats holds statistics about the compilation process
type CompilationStats struct {
        ErrorCount   int
        WarningCount int
        MemoryUsage  int
        NodesCreated int
}

// validateComponents ensures all required components are set
func (cp *DefaultCompilerPipeline) validateComponents() error <span class="cov0" title="0">{
        if cp.lexer == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("lexer not set")
        }</span>
        <span class="cov0" title="0">if cp.parser == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parser not set")
        }</span>
        <span class="cov0" title="0">if cp.semanticAnalyzer == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("semantic analyzer not set")
        }</span>
        <span class="cov0" title="0">if cp.codeGenerator == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("code generator not set")
        }</span>
        <span class="cov0" title="0">if cp.errorReporter == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reporter not set")
        }</span>
        <span class="cov0" title="0">if cp.typeRegistry == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("type registry not set")
        }</span>
        <span class="cov0" title="0">if cp.symbolTable == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("symbol table not set")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Reset resets the pipeline state for a new compilation
func (cp *DefaultCompilerPipeline) Reset() <span class="cov0" title="0">{
        if cp.errorReporter != nil </span><span class="cov0" title="0">{
                cp.errorReporter.Clear()
        }</span>
        <span class="cov0" title="0">if cp.symbolTable != nil </span><span class="cov0" title="0">{
                // Reset symbol table if it has a Reset method
                if resettable, ok := cp.symbolTable.(interface{ Reset() }); ok </span><span class="cov0" title="0">{
                        resettable.Reset()
                }</span>
        }
        <span class="cov0" title="0">if cp.memoryManager != nil </span><span class="cov0" title="0">{
                cp.memoryManager.FreeAll()
        }</span>
}

// MultiFileCompilerPipeline extends DefaultCompilerPipeline for multi-file compilation
type MultiFileCompilerPipeline struct {
        *DefaultCompilerPipeline
        fileContexts map[string]*domain.CompilationContext
        linkOrder    []string
}

// NewMultiFileCompilerPipeline creates a new multi-file compiler pipeline
func NewMultiFileCompilerPipeline() *MultiFileCompilerPipeline <span class="cov8" title="1">{
        return &amp;MultiFileCompilerPipeline{
                DefaultCompilerPipeline: NewDefaultCompilerPipeline(),
                fileContexts:            make(map[string]*domain.CompilationContext),
                linkOrder:               make([]string, 0),
        }
}</span>

// CompileFiles compiles multiple source files
func (mcp *MultiFileCompilerPipeline) CompileFiles(files map[string]io.Reader, output io.Writer) error <span class="cov0" title="0">{
        // Phase 1: Parse all files and build global symbol table
        asts := make(map[string]*domain.Program)

        for filename, input := range files </span><span class="cov0" title="0">{
                // Create file-specific context
                context := &amp;domain.CompilationContext{
                        SourceFiles:   make(map[string][]byte),
                        ErrorReporter: mcp.errorReporter,
                        Options:       mcp.options,
                }
                mcp.fileContexts[filename] = context

                // Parse the file
                if err := mcp.lexer.SetInput(filename, input); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set input for %s: %w", filename, err)
                }</span>

                <span class="cov0" title="0">ast, err := mcp.parser.Parse(mcp.lexer)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse %s: %w", filename, err)
                }</span>

                <span class="cov0" title="0">asts[filename] = ast
                mcp.linkOrder = append(mcp.linkOrder, filename)</span>
        }

        // Check for parsing errors
        <span class="cov0" title="0">if mcp.errorReporter.HasErrors() </span><span class="cov0" title="0">{
                return fmt.Errorf("parsing failed with %d error(s)", len(mcp.errorReporter.GetErrors()))
        }</span>

        // Phase 2: Semantic analysis across all files
        <span class="cov0" title="0">for _, filename := range mcp.linkOrder </span><span class="cov0" title="0">{
                ast := asts[filename]
                if err := mcp.semanticAnalyzer.Analyze(ast); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("semantic analysis failed for %s: %w", filename, err)
                }</span>
        }

        // Check for semantic errors
        <span class="cov0" title="0">if mcp.errorReporter.HasErrors() </span><span class="cov0" title="0">{
                return fmt.Errorf("semantic analysis failed with %d error(s)", len(mcp.errorReporter.GetErrors()))
        }</span>

        // Phase 3: Code generation for all files
        <span class="cov0" title="0">mcp.codeGenerator.SetOutput(output)
        mcp.codeGenerator.SetOptions(interfaces.CodeGenOptions{
                OptimizationLevel: mcp.options.OptimizationLevel,
                DebugInfo:         mcp.options.DebugInfo,
                TargetTriple:      mcp.options.TargetTriple,
        })

        for _, filename := range mcp.linkOrder </span><span class="cov0" title="0">{
                ast := asts[filename]
                if err := mcp.codeGenerator.Generate(ast); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("code generation failed for %s: %w", filename, err)
                }</span>
        }

        // Check for code generation errors
        <span class="cov0" title="0">if mcp.errorReporter.HasErrors() </span><span class="cov0" title="0">{
                return fmt.Errorf("code generation failed with %d error(s)", len(mcp.errorReporter.GetErrors()))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFileContext returns the compilation context for a specific file
func (mcp *MultiFileCompilerPipeline) GetFileContext(filename string) (*domain.CompilationContext, bool) <span class="cov0" title="0">{
        context, exists := mcp.fileContexts[filename]
        return context, exists
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package domain contains AST node definitions and visitor interfaces
package domain

// Node represents the base interface for all AST nodes
type Node interface {
        GetLocation() SourceRange
        Accept(visitor Visitor) error
}

// Visitor defines the visitor pattern interface for AST traversal
type Visitor interface {
        // Expressions
        VisitLiteralExpr(expr *LiteralExpr) error
        VisitIdentifierExpr(expr *IdentifierExpr) error
        VisitBinaryExpr(expr *BinaryExpr) error
        VisitUnaryExpr(expr *UnaryExpr) error
        VisitCallExpr(expr *CallExpr) error
        VisitIndexExpr(expr *IndexExpr) error
        VisitMemberExpr(expr *MemberExpr) error

        // Statements
        VisitExprStmt(stmt *ExprStmt) error
        VisitVarDeclStmt(stmt *VarDeclStmt) error
        VisitAssignStmt(stmt *AssignStmt) error
        VisitIfStmt(stmt *IfStmt) error
        VisitWhileStmt(stmt *WhileStmt) error
        VisitForStmt(stmt *ForStmt) error
        VisitReturnStmt(stmt *ReturnStmt) error
        VisitBlockStmt(stmt *BlockStmt) error

        // Declarations
        VisitFunctionDecl(decl *FunctionDecl) error
        VisitStructDecl(decl *StructDecl) error
        VisitProgram(prog *Program) error
}

// Expression interface for all expression nodes
type Expression interface {
        Node
        GetType() Type
        SetType(t Type)
}

// Statement interface for all statement nodes
type Statement interface {
        Node
}

// Declaration interface for all declaration nodes
type Declaration interface {
        Node
        GetName() string
}

// BaseNode provides common functionality for all AST nodes
type BaseNode struct {
        Location SourceRange
}

func (b *BaseNode) GetLocation() SourceRange <span class="cov8" title="1">{
        return b.Location
}</span>

// Expression nodes
type LiteralExpr struct {
        BaseNode
        Value interface{}
        Type_ Type
}

func (e *LiteralExpr) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitLiteralExpr(e) }</span>
func (e *LiteralExpr) GetType() Type                <span class="cov8" title="1">{ return e.Type_ }</span>
func (e *LiteralExpr) SetType(t Type)               <span class="cov8" title="1">{ e.Type_ = t }</span>

type IdentifierExpr struct {
        BaseNode
        Name  string
        Type_ Type
}

func (e *IdentifierExpr) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitIdentifierExpr(e) }</span>
func (e *IdentifierExpr) GetType() Type                <span class="cov8" title="1">{ return e.Type_ }</span>
func (e *IdentifierExpr) SetType(t Type)               <span class="cov8" title="1">{ e.Type_ = t }</span>

type BinaryExpr struct {
        BaseNode
        Left     Expression
        Operator BinaryOperator
        Right    Expression
        Type_    Type
}

func (e *BinaryExpr) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitBinaryExpr(e) }</span>
func (e *BinaryExpr) GetType() Type                <span class="cov0" title="0">{ return e.Type_ }</span>
func (e *BinaryExpr) SetType(t Type)               <span class="cov0" title="0">{ e.Type_ = t }</span>

type UnaryExpr struct {
        BaseNode
        Operator UnaryOperator
        Operand  Expression
        Type_    Type
}

func (e *UnaryExpr) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitUnaryExpr(e) }</span>
func (e *UnaryExpr) GetType() Type                <span class="cov0" title="0">{ return e.Type_ }</span>
func (e *UnaryExpr) SetType(t Type)               <span class="cov0" title="0">{ e.Type_ = t }</span>

type CallExpr struct {
        BaseNode
        Function Expression
        Args     []Expression
        Type_    Type
}

func (e *CallExpr) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitCallExpr(e) }</span>
func (e *CallExpr) GetType() Type                <span class="cov0" title="0">{ return e.Type_ }</span>
func (e *CallExpr) SetType(t Type)               <span class="cov0" title="0">{ e.Type_ = t }</span>

type IndexExpr struct {
        BaseNode
        Object Expression
        Index  Expression
        Type_  Type
}

func (e *IndexExpr) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitIndexExpr(e) }</span>
func (e *IndexExpr) GetType() Type                <span class="cov0" title="0">{ return e.Type_ }</span>
func (e *IndexExpr) SetType(t Type)               <span class="cov0" title="0">{ e.Type_ = t }</span>

type MemberExpr struct {
        BaseNode
        Object Expression
        Member string
        Type_  Type
}

func (e *MemberExpr) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitMemberExpr(e) }</span>
func (e *MemberExpr) GetType() Type                <span class="cov0" title="0">{ return e.Type_ }</span>
func (e *MemberExpr) SetType(t Type)               <span class="cov0" title="0">{ e.Type_ = t }</span>

// Statement nodes
type ExprStmt struct {
        BaseNode
        Expression Expression
}

func (s *ExprStmt) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitExprStmt(s) }</span>

type VarDeclStmt struct {
        BaseNode
        Name        string
        Type_       Type
        Initializer Expression
}

func (s *VarDeclStmt) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitVarDeclStmt(s) }</span>
func (s *VarDeclStmt) GetName() string              <span class="cov0" title="0">{ return s.Name }</span>

type AssignStmt struct {
        BaseNode
        Target Expression
        Value  Expression
}

func (s *AssignStmt) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitAssignStmt(s) }</span>

type IfStmt struct {
        BaseNode
        Condition Expression
        ThenStmt  Statement
        ElseStmt  Statement // optional
}

func (s *IfStmt) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitIfStmt(s) }</span>

type WhileStmt struct {
        BaseNode
        Condition Expression
        Body      Statement
}

func (s *WhileStmt) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitWhileStmt(s) }</span>

type ForStmt struct {
        BaseNode
        Init      Statement  // optional
        Condition Expression // optional
        Update    Statement  // optional
        Body      Statement
}

func (s *ForStmt) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitForStmt(s) }</span>

type ReturnStmt struct {
        BaseNode
        Value Expression // optional
}

func (s *ReturnStmt) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitReturnStmt(s) }</span>

type BlockStmt struct {
        BaseNode
        Statements []Statement
}

func (s *BlockStmt) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitBlockStmt(s) }</span>

// Declaration nodes
type Parameter struct {
        Name string
        Type Type
}

type FunctionDecl struct {
        BaseNode
        Name       string
        Parameters []Parameter
        ReturnType Type
        Body       *BlockStmt
}

func (d *FunctionDecl) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitFunctionDecl(d) }</span>
func (d *FunctionDecl) GetName() string              <span class="cov8" title="1">{ return d.Name }</span>

type StructField struct {
        Name string
        Type Type
}

type StructDecl struct {
        BaseNode
        Name   string
        Fields []StructField
}

func (d *StructDecl) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitStructDecl(d) }</span>
func (d *StructDecl) GetName() string              <span class="cov8" title="1">{ return d.Name }</span>

type Program struct {
        BaseNode
        Declarations []Declaration
}

func (p *Program) Accept(visitor Visitor) error <span class="cov0" title="0">{ return visitor.VisitProgram(p) }</span>

// Operator types
type BinaryOperator int

const (
        // Arithmetic
        Add BinaryOperator = iota
        Sub
        Mul
        Div
        Mod

        // Comparison
        Eq
        Ne
        Lt
        Le
        Gt
        Ge

        // Logical
        And
        Or
)

func (op BinaryOperator) String() string <span class="cov8" title="1">{
        switch op </span>{
        case Add:<span class="cov8" title="1">
                return "+"</span>
        case Sub:<span class="cov8" title="1">
                return "-"</span>
        case Mul:<span class="cov8" title="1">
                return "*"</span>
        case Div:<span class="cov8" title="1">
                return "/"</span>
        case Mod:<span class="cov8" title="1">
                return "%"</span>
        case Eq:<span class="cov8" title="1">
                return "=="</span>
        case Ne:<span class="cov8" title="1">
                return "!="</span>
        case Lt:<span class="cov8" title="1">
                return "&lt;"</span>
        case Le:<span class="cov8" title="1">
                return "&lt;="</span>
        case Gt:<span class="cov8" title="1">
                return "&gt;"</span>
        case Ge:<span class="cov8" title="1">
                return "&gt;="</span>
        case And:<span class="cov8" title="1">
                return "&amp;&amp;"</span>
        case Or:<span class="cov8" title="1">
                return "||"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

type UnaryOperator int

const (
        Neg UnaryOperator = iota // -
        Not                      // !
)

func (op UnaryOperator) String() string <span class="cov8" title="1">{
        switch op </span>{
        case Neg:<span class="cov8" title="1">
                return "-"</span>
        case Not:<span class="cov8" title="1">
                return "!"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package domain contains the type system definitions
package domain

import (
        "fmt"
        "strings"
)

// Type represents a type in the StaticLang type system
type Type interface {
        String() string
        Equals(other Type) bool
        IsAssignableFrom(other Type) bool
        GetSize() int // Size in bytes
}

// BasicType represents primitive types
type BasicType struct {
        Kind BasicTypeKind
}

type BasicTypeKind int

const (
        IntType BasicTypeKind = iota
        FloatType
        BoolType
        StringType
        VoidType
)

func (bt *BasicType) String() string <span class="cov8" title="1">{
        switch bt.Kind </span>{
        case IntType:<span class="cov8" title="1">
                return "int"</span>
        case FloatType:<span class="cov8" title="1">
                return "float"</span>
        case BoolType:<span class="cov8" title="1">
                return "bool"</span>
        case StringType:<span class="cov8" title="1">
                return "string"</span>
        case VoidType:<span class="cov8" title="1">
                return "void"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

func (bt *BasicType) Equals(other Type) bool <span class="cov8" title="1">{
        if otherBasic, ok := other.(*BasicType); ok </span><span class="cov8" title="1">{
                return bt.Kind == otherBasic.Kind
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (bt *BasicType) IsAssignableFrom(other Type) bool <span class="cov8" title="1">{
        return bt.Equals(other)
}</span>

func (bt *BasicType) GetSize() int <span class="cov8" title="1">{
        switch bt.Kind </span>{
        case IntType:<span class="cov8" title="1">
                return 8</span> // 64-bit integers
        case FloatType:<span class="cov8" title="1">
                return 8</span> // 64-bit floats
        case BoolType:<span class="cov8" title="1">
                return 1</span>
        case StringType:<span class="cov8" title="1">
                return 8</span> // pointer to string data
        case VoidType:<span class="cov8" title="1">
                return 0</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// ArrayType represents array types
type ArrayType struct {
        ElementType Type
        Size        int // -1 for dynamic arrays
}

func (at *ArrayType) String() string <span class="cov8" title="1">{
        if at.Size == -1 </span><span class="cov8" title="1">{
                return fmt.Sprintf("[]%s", at.ElementType.String())
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("[%d]%s", at.Size, at.ElementType.String())</span>
}

func (at *ArrayType) Equals(other Type) bool <span class="cov8" title="1">{
        if otherArray, ok := other.(*ArrayType); ok </span><span class="cov8" title="1">{
                return at.Size == otherArray.Size &amp;&amp; at.ElementType.Equals(otherArray.ElementType)
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (at *ArrayType) IsAssignableFrom(other Type) bool <span class="cov8" title="1">{
        if otherArray, ok := other.(*ArrayType); ok </span><span class="cov8" title="1">{
                // Dynamic arrays can accept static arrays of the same element type
                if at.Size == -1 &amp;&amp; otherArray.Size &gt;= 0 </span><span class="cov8" title="1">{
                        return at.ElementType.Equals(otherArray.ElementType)
                }</span>
                <span class="cov8" title="1">return at.Equals(other)</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (at *ArrayType) GetSize() int <span class="cov8" title="1">{
        if at.Size == -1 </span><span class="cov8" title="1">{
                return 8 // pointer to array data
        }</span>
        <span class="cov8" title="1">return at.Size * at.ElementType.GetSize()</span>
}

// StructType represents struct types
type StructType struct {
        Name   string
        Fields map[string]Type
        Order  []string // Preserve field order
}

func (st *StructType) String() string <span class="cov8" title="1">{
        if st.Name != "" </span><span class="cov8" title="1">{
                return st.Name
        }</span>

        // If no name, show field details
        <span class="cov8" title="1">if len(st.Fields) == 0 </span><span class="cov0" title="0">{
                return "struct{}"
        }</span>

        // Use Order slice if populated, otherwise use field map keys (order not guaranteed)
        <span class="cov8" title="1">var fieldNames []string
        if len(st.Order) &gt; 0 </span><span class="cov8" title="1">{
                fieldNames = st.Order
        }</span> else<span class="cov0" title="0"> {
                for fieldName := range st.Fields </span><span class="cov0" title="0">{
                        fieldNames = append(fieldNames, fieldName)
                }</span>
        }

        <span class="cov8" title="1">fields := make([]string, len(fieldNames))
        for i, fieldName := range fieldNames </span><span class="cov8" title="1">{
                fieldType := st.Fields[fieldName]
                fields[i] = fieldName + " " + fieldType.String()
        }</span>

        <span class="cov8" title="1">return "struct{" + strings.Join(fields, ", ") + "}"</span>
}

func (st *StructType) Equals(other Type) bool <span class="cov8" title="1">{
        if otherStruct, ok := other.(*StructType); ok </span><span class="cov8" title="1">{
                return st.Name == otherStruct.Name
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (st *StructType) IsAssignableFrom(other Type) bool <span class="cov8" title="1">{
        return st.Equals(other)
}</span>

func (st *StructType) GetSize() int <span class="cov0" title="0">{
        size := 0
        for _, fieldName := range st.Order </span><span class="cov0" title="0">{
                fieldType := st.Fields[fieldName]
                size += fieldType.GetSize()
        }</span>
        <span class="cov0" title="0">return size</span>
}

func (st *StructType) GetField(name string) (Type, bool) <span class="cov8" title="1">{
        fieldType, exists := st.Fields[name]
        return fieldType, exists
}</span>

// FunctionType represents function types
type FunctionType struct {
        ParameterTypes []Type
        ReturnType     Type
}

func (ft *FunctionType) String() string <span class="cov8" title="1">{
        params := make([]string, len(ft.ParameterTypes))
        for i, param := range ft.ParameterTypes </span><span class="cov8" title="1">{
                params[i] = param.String()
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("func(%s) %s", strings.Join(params, ", "), ft.ReturnType.String())</span>
}

func (ft *FunctionType) Equals(other Type) bool <span class="cov8" title="1">{
        if otherFunc, ok := other.(*FunctionType); ok </span><span class="cov8" title="1">{
                if len(ft.ParameterTypes) != len(otherFunc.ParameterTypes) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">for i, param := range ft.ParameterTypes </span><span class="cov8" title="1">{
                        if !param.Equals(otherFunc.ParameterTypes[i]) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return ft.ReturnType.Equals(otherFunc.ReturnType)</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (ft *FunctionType) IsAssignableFrom(other Type) bool <span class="cov0" title="0">{
        return ft.Equals(other)
}</span>

func (ft *FunctionType) GetSize() int <span class="cov0" title="0">{
        return 8 // function pointer
}</span>

// TypeError represents an error type for type checking failures
type TypeError struct {
        Message string
}

func (et *TypeError) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("&lt;error: %s&gt;", et.Message)
}</span>

func (et *TypeError) Equals(other Type) bool <span class="cov0" title="0">{
        _, ok := other.(*TypeError)
        return ok
}</span>

func (et *TypeError) IsAssignableFrom(other Type) bool <span class="cov8" title="1">{
        return false
}</span>

func (et *TypeError) GetSize() int <span class="cov8" title="1">{
        return 0
}</span>

// TypeRegistry manages type definitions and provides type operations
type TypeRegistry interface {
        RegisterType(name string, t Type) error
        GetType(name string) (Type, bool)
        CreateStructType(name string, fields []StructField) (*StructType, error)
        GetBuiltinType(kind BasicTypeKind) Type
}

// DefaultTypeRegistry provides the default implementation of TypeRegistry
type DefaultTypeRegistry struct {
        types    map[string]Type
        builtins map[BasicTypeKind]Type
}

func NewDefaultTypeRegistry() *DefaultTypeRegistry <span class="cov8" title="1">{
        reg := &amp;DefaultTypeRegistry{
                types:    make(map[string]Type),
                builtins: make(map[BasicTypeKind]Type),
        }

        // Register builtin types
        reg.builtins[IntType] = &amp;BasicType{Kind: IntType}
        reg.builtins[FloatType] = &amp;BasicType{Kind: FloatType}
        reg.builtins[BoolType] = &amp;BasicType{Kind: BoolType}
        reg.builtins[StringType] = &amp;BasicType{Kind: StringType}
        reg.builtins[VoidType] = &amp;BasicType{Kind: VoidType}

        // Also register them by name
        reg.types["int"] = reg.builtins[IntType]
        reg.types["float"] = reg.builtins[FloatType]
        reg.types["bool"] = reg.builtins[BoolType]
        reg.types["string"] = reg.builtins[StringType]
        reg.types["void"] = reg.builtins[VoidType]

        return reg
}</span>

// NewTypeRegistry creates a new type registry
func NewTypeRegistry() TypeRegistry <span class="cov8" title="1">{
        return NewDefaultTypeRegistry()
}</span>

func (reg *DefaultTypeRegistry) RegisterType(name string, t Type) error <span class="cov8" title="1">{
        if _, exists := reg.types[name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("type '%s' already registered", name)
        }</span>
        <span class="cov8" title="1">reg.types[name] = t
        return nil</span>
}

func (reg *DefaultTypeRegistry) GetType(name string) (Type, bool) <span class="cov8" title="1">{
        t, exists := reg.types[name]
        return t, exists
}</span>

func (reg *DefaultTypeRegistry) CreateStructType(name string, fields []StructField) (*StructType, error) <span class="cov0" title="0">{
        if _, exists := reg.types[name]; exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("type '%s' already exists", name)
        }</span>

        <span class="cov0" title="0">structType := &amp;StructType{
                Name:   name,
                Fields: make(map[string]Type),
                Order:  make([]string, 0, len(fields)),
        }

        for _, field := range fields </span><span class="cov0" title="0">{
                if _, exists := structType.Fields[field.Name]; exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("duplicate field '%s' in struct '%s'", field.Name, name)
                }</span>
                <span class="cov0" title="0">structType.Fields[field.Name] = field.Type
                structType.Order = append(structType.Order, field.Name)</span>
        }

        <span class="cov0" title="0">reg.types[name] = structType
        return structType, nil</span>
}

func (reg *DefaultTypeRegistry) GetBuiltinType(kind BasicTypeKind) Type <span class="cov8" title="1">{
        return reg.builtins[kind]
}</span>

// Type checking utilities
func IsNumericType(t Type) bool <span class="cov8" title="1">{
        if basic, ok := t.(*BasicType); ok </span><span class="cov8" title="1">{
                return basic.Kind == IntType || basic.Kind == FloatType
        }</span>
        <span class="cov0" title="0">return false</span>
}

func IsComparableType(t Type) bool <span class="cov8" title="1">{
        if basic, ok := t.(*BasicType); ok </span><span class="cov8" title="1">{
                return basic.Kind == IntType || basic.Kind == FloatType || basic.Kind == BoolType || basic.Kind == StringType
        }</span>
        <span class="cov0" title="0">return false</span>
}

func CanApplyBinaryOperator(op BinaryOperator, left, right Type) bool <span class="cov8" title="1">{
        switch op </span>{
        case Add, Sub, Mul, Div, Mod:<span class="cov8" title="1">
                return IsNumericType(left) &amp;&amp; left.Equals(right)</span>
        case Eq, Ne:<span class="cov0" title="0">
                return IsComparableType(left) &amp;&amp; left.Equals(right)</span>
        case Lt, Le, Gt, Ge:<span class="cov8" title="1">
                return (IsNumericType(left) || left.String() == "string") &amp;&amp; left.Equals(right)</span>
        case And, Or:<span class="cov8" title="1">
                return left.String() == "bool" &amp;&amp; right.String() == "bool"</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// Helper functions for creating basic types
func NewIntType() Type <span class="cov8" title="1">{
        return &amp;BasicType{Kind: IntType}
}</span>

func NewFloatType() Type <span class="cov8" title="1">{
        return &amp;BasicType{Kind: FloatType}
}</span>

func NewBoolType() Type <span class="cov8" title="1">{
        return &amp;BasicType{Kind: BoolType}
}</span>

func NewStringType() Type <span class="cov8" title="1">{
        return &amp;BasicType{Kind: StringType}
}</span>

func NewVoidType() Type <span class="cov8" title="1">{
        return &amp;BasicType{Kind: VoidType}
}</span>

func CanApplyUnaryOperator(op UnaryOperator, operand Type) bool <span class="cov8" title="1">{
        switch op </span>{
        case Neg:<span class="cov8" title="1">
                return IsNumericType(operand)</span>
        case Not:<span class="cov8" title="1">
                return operand.String() == "bool"</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package domain contains the core domain types and interfaces for the StaticLang compiler
package domain

import (
        "fmt"
)

// SourcePosition represents a position in the source code
type SourcePosition struct {
        Filename string
        Line     int
        Column   int
        Offset   int
}

func (pos SourcePosition) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d:%d", pos.Filename, pos.Line, pos.Column)
}</span>

// SourceRange represents a range in the source code
type SourceRange struct {
        Start SourcePosition
        End   SourcePosition
}

func (r SourceRange) String() string <span class="cov0" title="0">{
        if r.Start.Filename == r.End.Filename </span><span class="cov0" title="0">{
                if r.Start.Line == r.End.Line </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s:%d:%d-%d", r.Start.Filename, r.Start.Line, r.Start.Column, r.End.Column)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%s:%d:%d-%d:%d", r.Start.Filename, r.Start.Line, r.Start.Column, r.End.Line, r.End.Column)</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("%s-%s", r.Start.String(), r.End.String())</span>
}

// CompilerError represents different types of compilation errors
type CompilerError struct {
        Type     ErrorType
        Message  string
        Location SourceRange
        Context  string
        Hints    []string
}

type ErrorType int

const (
        LexicalError ErrorType = iota
        SyntaxError
        SemanticError
        TypeCheckError
        CodeGenError
        InternalError
)

func (e CompilerError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s: %s at %s", e.Type, e.Message, e.Location)
}</span>

func (et ErrorType) String() string <span class="cov0" title="0">{
        switch et </span>{
        case LexicalError:<span class="cov0" title="0">
                return "Lexical Error"</span>
        case SyntaxError:<span class="cov0" title="0">
                return "Syntax Error"</span>
        case SemanticError:<span class="cov0" title="0">
                return "Semantic Error"</span>
        case TypeCheckError:<span class="cov0" title="0">
                return "Type Error"</span>
        case CodeGenError:<span class="cov0" title="0">
                return "Code Generation Error"</span>
        case InternalError:<span class="cov0" title="0">
                return "Internal Error"</span>
        default:<span class="cov0" title="0">
                return "Unknown Error"</span>
        }
}

// ErrorReporter defines the interface for error reporting
type ErrorReporter interface {
        ReportError(err CompilerError)
        ReportWarning(warning CompilerError)
        HasErrors() bool
        HasWarnings() bool
        GetErrors() []CompilerError
        GetWarnings() []CompilerError
        Clear()
}

// CompilationContext holds the shared context for compilation
type CompilationContext struct {
        SourceFiles   map[string][]byte
        ErrorReporter ErrorReporter
        Options       CompilationOptions
}

// CompilationOptions holds compiler configuration
type CompilationOptions struct {
        OptimizationLevel int
        DebugInfo         bool
        TargetTriple      string
        OutputPath        string
        WarningsAsErrors  bool
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package infrastructure contains error reporting implementation
package infrastructure

import (
        "fmt"
        "io"
        "os"
        "sort"
        "strings"

        "github.com/sokoide/llvm5/internal/domain"
)

// ConsoleErrorReporter implements ErrorReporter for console output
type ConsoleErrorReporter struct {
        errors      []domain.CompilerError
        warnings    []domain.CompilerError
        output      io.Writer
        sourceMap   map[string][]byte // filename -&gt; source content
        maxErrors   int
        maxWarnings int
}

// NewConsoleErrorReporter creates a new console error reporter
func NewConsoleErrorReporter(output io.Writer) *ConsoleErrorReporter <span class="cov8" title="1">{
        if output == nil </span><span class="cov0" title="0">{
                output = os.Stderr
        }</span>

        <span class="cov8" title="1">return &amp;ConsoleErrorReporter{
                errors:      make([]domain.CompilerError, 0),
                warnings:    make([]domain.CompilerError, 0),
                output:      output,
                sourceMap:   make(map[string][]byte),
                maxErrors:   100, // Limit to prevent spam
                maxWarnings: 50,
        }</span>
}

// SetSourceContent sets the source content for a file (for better error reporting)
func (er *ConsoleErrorReporter) SetSourceContent(filename string, content []byte) <span class="cov8" title="1">{
        er.sourceMap[filename] = content
}</span>

// SetMaxErrors sets the maximum number of errors to report
func (er *ConsoleErrorReporter) SetMaxErrors(max int) <span class="cov8" title="1">{
        er.maxErrors = max
}</span>

// SetMaxWarnings sets the maximum number of warnings to report
func (er *ConsoleErrorReporter) SetMaxWarnings(max int) <span class="cov8" title="1">{
        er.maxWarnings = max
}</span>

// ReportError reports a compilation error
func (er *ConsoleErrorReporter) ReportError(err domain.CompilerError) <span class="cov8" title="1">{
        if len(er.errors) &lt; er.maxErrors </span><span class="cov8" title="1">{
                er.errors = append(er.errors, err)
                er.printError(err, "error")
        }</span>
}

// ReportWarning reports a compilation warning
func (er *ConsoleErrorReporter) ReportWarning(warning domain.CompilerError) <span class="cov8" title="1">{
        if len(er.warnings) &lt; er.maxWarnings </span><span class="cov8" title="1">{
                er.warnings = append(er.warnings, warning)
                er.printError(warning, "warning")
        }</span>
}

// HasErrors returns true if any errors have been reported
func (er *ConsoleErrorReporter) HasErrors() bool <span class="cov8" title="1">{
        return len(er.errors) &gt; 0
}</span>

// HasWarnings returns true if any warnings have been reported
func (er *ConsoleErrorReporter) HasWarnings() bool <span class="cov8" title="1">{
        return len(er.warnings) &gt; 0
}</span>

// GetErrors returns all reported errors
func (er *ConsoleErrorReporter) GetErrors() []domain.CompilerError <span class="cov8" title="1">{
        // Return a copy to prevent modification
        errors := make([]domain.CompilerError, len(er.errors))
        copy(errors, er.errors)
        return errors
}</span>

// GetWarnings returns all reported warnings
func (er *ConsoleErrorReporter) GetWarnings() []domain.CompilerError <span class="cov8" title="1">{
        // Return a copy to prevent modification
        warnings := make([]domain.CompilerError, len(er.warnings))
        copy(warnings, er.warnings)
        return warnings
}</span>

// Clear clears all errors and warnings
func (er *ConsoleErrorReporter) Clear() <span class="cov8" title="1">{
        er.errors = er.errors[:0]
        er.warnings = er.warnings[:0]
}</span>

// PrintSummary prints a summary of all errors and warnings
func (er *ConsoleErrorReporter) PrintSummary() <span class="cov0" title="0">{
        if er.HasErrors() || er.HasWarnings() </span><span class="cov0" title="0">{
                fmt.Fprintf(er.output, "\n")

                if er.HasErrors() </span><span class="cov0" title="0">{
                        fmt.Fprintf(er.output, "Found %d error(s)\n", len(er.errors))
                }</span>

                <span class="cov0" title="0">if er.HasWarnings() </span><span class="cov0" title="0">{
                        fmt.Fprintf(er.output, "Found %d warning(s)\n", len(er.warnings))
                }</span>
        }
}

// printError prints a formatted error or warning message
func (er *ConsoleErrorReporter) printError(err domain.CompilerError, severity string) <span class="cov8" title="1">{
        // Print basic error information
        fmt.Fprintf(er.output, "%s: %s: %s\n", err.Location.String(), severity, err.Message)

        // Print source context if available
        if content, exists := er.sourceMap[err.Location.Start.Filename]; exists </span><span class="cov8" title="1">{
                er.printSourceContext(content, err.Location)
        }</span>

        // Print additional context if available
        <span class="cov8" title="1">if err.Context != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(er.output, "  Context: %s\n", err.Context)
        }</span>

        // Print hints if available
        <span class="cov8" title="1">for _, hint := range err.Hints </span><span class="cov0" title="0">{
                fmt.Fprintf(er.output, "  Hint: %s\n", hint)
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(er.output, "\n")</span>
}

// printSourceContext prints the relevant source code context
func (er *ConsoleErrorReporter) printSourceContext(content []byte, location domain.SourceRange) <span class="cov8" title="1">{
        lines := strings.Split(string(content), "\n")

        startLine := location.Start.Line - 1 // Convert to 0-based
        endLine := location.End.Line - 1

        // Validate line numbers
        if startLine &lt; 0 || startLine &gt;= len(lines) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if endLine &gt;= len(lines) </span><span class="cov0" title="0">{
                endLine = len(lines) - 1
        }</span>

        // Print a few lines before the error for context
        <span class="cov8" title="1">contextStart := max(0, startLine-2)
        contextEnd := min(len(lines)-1, endLine+2)

        lineNumWidth := len(fmt.Sprintf("%d", contextEnd+1))

        for i := contextStart; i &lt;= contextEnd; i++ </span><span class="cov8" title="1">{
                lineNum := i + 1
                prefix := fmt.Sprintf("%*d | ", lineNumWidth, lineNum)

                if i &gt;= startLine &amp;&amp; i &lt;= endLine </span><span class="cov8" title="1">{
                        // This is an error line - highlight it
                        fmt.Fprintf(er.output, "%s%s\n", prefix, lines[i])

                        if i == startLine </span><span class="cov8" title="1">{
                                // Add error indicator
                                indicator := strings.Repeat(" ", len(prefix))
                                if location.Start.Column &gt; 0 </span><span class="cov8" title="1">{
                                        indicator += strings.Repeat(" ", location.Start.Column-1)
                                }</span>

                                // Calculate length of error indicator
                                <span class="cov8" title="1">indicatorLength := 1
                                if startLine == endLine &amp;&amp; location.End.Column &gt; location.Start.Column </span><span class="cov8" title="1">{
                                        indicatorLength = location.End.Column - location.Start.Column
                                }</span>

                                <span class="cov8" title="1">indicator += strings.Repeat("^", indicatorLength)
                                fmt.Fprintf(er.output, "%s\n", indicator)</span>
                        }
                } else<span class="cov8" title="1"> {
                        // Context line
                        fmt.Fprintf(er.output, "%s%s\n", prefix, lines[i])
                }</span>
        }
}

// SortedErrorReporter wraps another ErrorReporter and sorts errors by location
type SortedErrorReporter struct {
        underlying domain.ErrorReporter
        errors     []domain.CompilerError
        warnings   []domain.CompilerError
}

// NewSortedErrorReporter creates a new sorted error reporter
func NewSortedErrorReporter(underlying domain.ErrorReporter) *SortedErrorReporter <span class="cov8" title="1">{
        return &amp;SortedErrorReporter{
                underlying: underlying,
                errors:     make([]domain.CompilerError, 0),
                warnings:   make([]domain.CompilerError, 0),
        }
}</span>

// ReportError collects errors for later sorted reporting
func (ser *SortedErrorReporter) ReportError(err domain.CompilerError) <span class="cov8" title="1">{
        ser.errors = append(ser.errors, err)
}</span>

// ReportWarning collects warnings for later sorted reporting
func (ser *SortedErrorReporter) ReportWarning(warning domain.CompilerError) <span class="cov0" title="0">{
        ser.warnings = append(ser.warnings, warning)
}</span>

// HasErrors returns true if any errors have been reported
func (ser *SortedErrorReporter) HasErrors() bool <span class="cov8" title="1">{
        return len(ser.errors) &gt; 0
}</span>

// HasWarnings returns true if any warnings have been reported
func (ser *SortedErrorReporter) HasWarnings() bool <span class="cov0" title="0">{
        return len(ser.warnings) &gt; 0
}</span>

// GetErrors returns all reported errors
func (ser *SortedErrorReporter) GetErrors() []domain.CompilerError <span class="cov8" title="1">{
        errors := make([]domain.CompilerError, len(ser.errors))
        copy(errors, ser.errors)
        return errors
}</span>

// GetWarnings returns all reported warnings
func (ser *SortedErrorReporter) GetWarnings() []domain.CompilerError <span class="cov0" title="0">{
        warnings := make([]domain.CompilerError, len(ser.warnings))
        copy(warnings, ser.warnings)
        return warnings
}</span>

// Clear clears all collected errors and warnings
func (ser *SortedErrorReporter) Clear() <span class="cov8" title="1">{
        ser.errors = ser.errors[:0]
        ser.warnings = ser.warnings[:0]
}</span>

// Flush sorts and reports all collected errors and warnings
func (ser *SortedErrorReporter) Flush() <span class="cov8" title="1">{
        // Sort errors by location
        sort.Slice(ser.errors, func(i, j int) bool </span><span class="cov8" title="1">{
                return compareSourceRanges(ser.errors[i].Location, ser.errors[j].Location)
        }</span>)

        <span class="cov8" title="1">sort.Slice(ser.warnings, func(i, j int) bool </span><span class="cov0" title="0">{
                return compareSourceRanges(ser.warnings[i].Location, ser.warnings[j].Location)
        }</span>)

        // Report sorted errors
        <span class="cov8" title="1">for _, err := range ser.errors </span><span class="cov8" title="1">{
                ser.underlying.ReportError(err)
        }</span>

        <span class="cov8" title="1">for _, warning := range ser.warnings </span><span class="cov0" title="0">{
                ser.underlying.ReportWarning(warning)
        }</span>

        <span class="cov8" title="1">ser.Clear()</span>
}

// compareSourceRanges compares two source ranges for sorting
func compareSourceRanges(a, b domain.SourceRange) bool <span class="cov8" title="1">{
        if a.Start.Filename != b.Start.Filename </span><span class="cov0" title="0">{
                return a.Start.Filename &lt; b.Start.Filename
        }</span>
        <span class="cov8" title="1">if a.Start.Line != b.Start.Line </span><span class="cov8" title="1">{
                return a.Start.Line &lt; b.Start.Line
        }</span>
        <span class="cov8" title="1">return a.Start.Column &lt; b.Start.Column</span>
}

// Helper functions
func max(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package infrastructure contains LLVM backend implementation
package infrastructure

import (
        "fmt"
        "io"
        "sync"

        "github.com/sokoide/llvm5/codegen"
        "github.com/sokoide/llvm5/internal/domain"
        "github.com/sokoide/llvm5/internal/interfaces"
)

// MockLLVMBackend provides a mock implementation for testing and development
type MockLLVMBackend struct {
        mutex        sync.RWMutex
        initialized  bool
        targetTriple string
        modules      map[string]*MockLLVMModule
        moduleCount  int
}

// NewMockLLVMBackend creates a new mock LLVM backend
func NewMockLLVMBackend() *MockLLVMBackend <span class="cov0" title="0">{
        return &amp;MockLLVMBackend{
                modules: make(map[string]*MockLLVMModule),
        }
}</span>

// Initialize initializes the LLVM backend
func (backend *MockLLVMBackend) Initialize(targetTriple string) error <span class="cov0" title="0">{
        backend.mutex.Lock()
        defer backend.mutex.Unlock()

        if backend.initialized </span><span class="cov0" title="0">{
                return fmt.Errorf("backend already initialized")
        }</span>

        <span class="cov0" title="0">backend.targetTriple = targetTriple
        backend.initialized = true

        return nil</span>
}

// CreateModule creates a new LLVM module
func (backend *MockLLVMBackend) CreateModule(name string) (interfaces.LLVMModule, error) <span class="cov0" title="0">{
        backend.mutex.Lock()
        defer backend.mutex.Unlock()

        if !backend.initialized </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("backend not initialized")
        }</span>

        <span class="cov0" title="0">module := &amp;MockLLVMModule{
                name:      name,
                backend:   backend,
                functions: make(map[string]*MockLLVMFunction),
                globals:   make(map[string]*MockLLVMValue),
                structs:   make(map[string]*MockLLVMType),
                verified:  false,
        }

        backend.modules[name] = module
        backend.moduleCount++

        return module, nil</span>
}

// Optimize optimizes the given module
func (backend *MockLLVMBackend) Optimize(module interfaces.LLVMModule, level int) error <span class="cov0" title="0">{
        backend.mutex.RLock()
        defer backend.mutex.RUnlock()

        // In a real implementation, this would run LLVM optimization passes
        mockModule, ok := module.(*MockLLVMModule)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid module type")
        }</span>

        <span class="cov0" title="0">mockModule.optimizationLevel = level
        return nil</span>
}

// EmitObject emits object code to the writer
func (backend *MockLLVMBackend) EmitObject(module interfaces.LLVMModule, output io.Writer) error <span class="cov0" title="0">{
        backend.mutex.RLock()
        defer backend.mutex.RUnlock()

        mockModule, ok := module.(*MockLLVMModule)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid module type")
        }</span>

        // Generate mock object code
        <span class="cov0" title="0">_, err := fmt.Fprintf(output, "; Mock object code for module %s\n", mockModule.name)
        return err</span>
}

// EmitAssembly emits assembly code to the writer
func (backend *MockLLVMBackend) EmitAssembly(module interfaces.LLVMModule, output io.Writer) error <span class="cov0" title="0">{
        backend.mutex.RLock()
        defer backend.mutex.RUnlock()

        mockModule, ok := module.(*MockLLVMModule)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid module type")
        }</span>

        // Generate mock assembly code
        <span class="cov0" title="0">_, err := fmt.Fprintf(output, "; Mock assembly code for module %s\n", mockModule.name)
        return err</span>
}

// Dispose disposes of backend resources
func (backend *MockLLVMBackend) Dispose() <span class="cov0" title="0">{
        backend.mutex.Lock()
        defer backend.mutex.Unlock()

        for _, module := range backend.modules </span><span class="cov0" title="0">{
                module.Dispose()
        }</span>
        <span class="cov0" title="0">backend.modules = make(map[string]*MockLLVMModule)
        backend.initialized = false</span>
}

// MockLLVMModule implements LLVMModule for testing
type MockLLVMModule struct {
        name              string
        backend           *MockLLVMBackend
        functions         map[string]*MockLLVMFunction
        globals           map[string]*MockLLVMValue
        structs           map[string]*MockLLVMType
        verified          bool
        optimizationLevel int
}

// CreateFunction creates a new function in the module
func (module *MockLLVMModule) CreateFunction(name string, funcType domain.Type) (interfaces.LLVMFunction, error) <span class="cov0" title="0">{
        if _, exists := module.functions[name]; exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function %s already exists", name)
        }</span>

        <span class="cov0" title="0">ft, ok := funcType.(*domain.FunctionType)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid function type")
        }</span>

        <span class="cov0" title="0">function := &amp;MockLLVMFunction{
                name:       name,
                funcType:   ft,
                module:     module,
                parameters: make([]*MockLLVMValue, len(ft.ParameterTypes)),
                blocks:     make(map[string]*MockLLVMBasicBlock),
        }

        // Create parameter values
        for i, paramType := range ft.ParameterTypes </span><span class="cov0" title="0">{
                function.parameters[i] = &amp;MockLLVMValue{
                        name:     fmt.Sprintf("param%d", i),
                        typ:      &amp;MockLLVMType{domainType: paramType},
                        function: function,
                }
        }</span>

        <span class="cov0" title="0">module.functions[name] = function
        return function, nil</span>
}

// CreateGlobalVariable creates a global variable
func (module *MockLLVMModule) CreateGlobalVariable(name string, varType domain.Type) (interfaces.LLVMValue, error) <span class="cov0" title="0">{
        if _, exists := module.globals[name]; exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("global variable %s already exists", name)
        }</span>

        <span class="cov0" title="0">global := &amp;MockLLVMValue{
                name: name,
                typ:  &amp;MockLLVMType{domainType: varType},
        }

        module.globals[name] = global
        return global, nil</span>
}

// CreateStruct creates a struct type
func (module *MockLLVMModule) CreateStruct(name string, structType *domain.StructType) (interfaces.LLVMType, error) <span class="cov0" title="0">{
        if _, exists := module.structs[name]; exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("struct %s already exists", name)
        }</span>

        <span class="cov0" title="0">llvmType := &amp;MockLLVMType{
                name:       name,
                domainType: structType,
                isStruct:   true,
        }

        module.structs[name] = llvmType
        return llvmType, nil</span>
}

// GetFunction gets a function by name
func (module *MockLLVMModule) GetFunction(name string) (interfaces.LLVMFunction, bool) <span class="cov0" title="0">{
        function, exists := module.functions[name]
        return function, exists
}</span>

// Verify verifies the module
func (module *MockLLVMModule) Verify() error <span class="cov0" title="0">{
        // Mock verification - check for basic consistency
        for _, function := range module.functions </span><span class="cov0" title="0">{
                if len(function.blocks) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("function %s has no basic blocks", function.name)
                }</span>

                // Check that each block is properly terminated
                <span class="cov0" title="0">for blockName, block := range function.blocks </span><span class="cov0" title="0">{
                        if !block.terminated </span><span class="cov0" title="0">{
                                return fmt.Errorf("basic block %s in function %s is not terminated", blockName, function.name)
                        }</span>
                }
        }

        <span class="cov0" title="0">module.verified = true
        return nil</span>
}

// Print prints the module IR
func (module *MockLLVMModule) Print(output io.Writer) <span class="cov0" title="0">{
        fmt.Fprintf(output, "; Module: %s\n", module.name)
        fmt.Fprintf(output, "target triple = \"%s\"\n\n", module.backend.targetTriple)

        // Print struct declarations
        for structName, structType := range module.structs </span><span class="cov0" title="0">{
                fmt.Fprintf(output, "%%struct.%s = type { ", structName)
                if st, ok := structType.domainType.(*domain.StructType); ok </span><span class="cov0" title="0">{
                        for i, fieldName := range st.Order </span><span class="cov0" title="0">{
                                if i &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Fprintf(output, ", ")
                                }</span>
                                <span class="cov0" title="0">fmt.Fprintf(output, "%s", st.Fields[fieldName].String())</span>
                        }
                }
                <span class="cov0" title="0">fmt.Fprintf(output, " }\n")</span>
        }

        // Print global variables
        <span class="cov0" title="0">for globalName, global := range module.globals </span><span class="cov0" title="0">{
                if mockType, ok := global.typ.(*MockLLVMType); ok </span><span class="cov0" title="0">{
                        fmt.Fprintf(output, "@%s = global %s\n", globalName, mockType.domainType.String())
                }</span>
        }

        // Print functions
        <span class="cov0" title="0">for _, function := range module.functions </span><span class="cov0" title="0">{
                function.print(output)
        }</span>
}

// Dispose disposes of the module
func (module *MockLLVMModule) Dispose() <span class="cov0" title="0">{
        for _, function := range module.functions </span><span class="cov0" title="0">{
                function.dispose()
        }</span>
        <span class="cov0" title="0">module.functions = make(map[string]*MockLLVMFunction)
        module.globals = make(map[string]*MockLLVMValue)
        module.structs = make(map[string]*MockLLVMType)</span>
}

// MockLLVMFunction implements LLVMFunction
type MockLLVMFunction struct {
        name       string
        funcType   *domain.FunctionType
        module     *MockLLVMModule
        parameters []*MockLLVMValue
        blocks     map[string]*MockLLVMBasicBlock
        blockCount int
}

// CreateBasicBlock creates a basic block in the function
func (function *MockLLVMFunction) CreateBasicBlock(name string) interfaces.LLVMBasicBlock <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                name = fmt.Sprintf("bb%d", function.blockCount)
        }</span>

        <span class="cov0" title="0">block := &amp;MockLLVMBasicBlock{
                name:       name,
                function:   function,
                terminated: false,
        }

        function.blocks[name] = block
        function.blockCount++

        return block</span>
}

// GetParameter gets a parameter by index
func (function *MockLLVMFunction) GetParameter(index int) interfaces.LLVMValue <span class="cov0" title="0">{
        if index &lt; 0 || index &gt;= len(function.parameters) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return function.parameters[index]</span>
}

// GetParameterCount gets the number of parameters
func (function *MockLLVMFunction) GetParameterCount() int <span class="cov0" title="0">{
        return len(function.parameters)
}</span>

// SetName sets the function name
func (function *MockLLVMFunction) SetName(name string) <span class="cov0" title="0">{
        function.name = name
}</span>

func (function *MockLLVMFunction) print(output io.Writer) <span class="cov0" title="0">{
        // Print function signature
        fmt.Fprintf(output, "define %s @%s(",
                function.funcType.ReturnType.String(),
                function.name)

        for i, paramType := range function.funcType.ParameterTypes </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Fprintf(output, ", ")
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(output, "%s %%param%d", paramType.String(), i)</span>
        }
        <span class="cov0" title="0">fmt.Fprintf(output, ") {\n")

        // Print basic blocks
        for _, block := range function.blocks </span><span class="cov0" title="0">{
                fmt.Fprintf(output, "%s:\n", block.name)
                // In a real implementation, we'd print the instructions
                fmt.Fprintf(output, "  ; block content\n")
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(output, "}\n\n")</span>
}

func (function *MockLLVMFunction) dispose() <span class="cov0" title="0">{
        for range function.blocks </span>{<span class="cov0" title="0">
                // Clean up block resources
        }</span>
        <span class="cov0" title="0">function.blocks = make(map[string]*MockLLVMBasicBlock)</span>
}

// MockLLVMBasicBlock implements LLVMBasicBlock
type MockLLVMBasicBlock struct {
        name       string
        function   *MockLLVMFunction
        terminated bool
}

// GetName gets the block name
func (block *MockLLVMBasicBlock) GetName() string <span class="cov0" title="0">{
        return block.name
}</span>

// IsTerminated checks if the block is terminated
func (block *MockLLVMBasicBlock) IsTerminated() bool <span class="cov0" title="0">{
        return block.terminated
}</span>

// MockLLVMValue implements LLVMValue
type MockLLVMValue struct {
        name     string
        typ      interfaces.LLVMType
        function *MockLLVMFunction
}

// GetType gets the value type
func (value *MockLLVMValue) GetType() interfaces.LLVMType <span class="cov0" title="0">{
        return value.typ
}</span>

// SetName sets the value name
func (value *MockLLVMValue) SetName(name string) <span class="cov0" title="0">{
        value.name = name
}</span>

// GetName gets the value name
func (value *MockLLVMValue) GetName() string <span class="cov0" title="0">{
        return value.name
}</span>

// MockLLVMType implements LLVMType
type MockLLVMType struct {
        name       string
        domainType domain.Type
        isStruct   bool
}

// IsInteger checks if the type is an integer
func (typ *MockLLVMType) IsInteger() bool <span class="cov0" title="0">{
        if basic, ok := typ.domainType.(*domain.BasicType); ok </span><span class="cov0" title="0">{
                return basic.Kind == domain.IntType
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsFloat checks if the type is a float
func (typ *MockLLVMType) IsFloat() bool <span class="cov0" title="0">{
        if basic, ok := typ.domainType.(*domain.BasicType); ok </span><span class="cov0" title="0">{
                return basic.Kind == domain.FloatType
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsPointer checks if the type is a pointer
func (typ *MockLLVMType) IsPointer() bool <span class="cov0" title="0">{
        // In this mock implementation, we'll consider string types as pointers
        if basic, ok := typ.domainType.(*domain.BasicType); ok </span><span class="cov0" title="0">{
                return basic.Kind == domain.StringType
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsStruct checks if the type is a struct
func (typ *MockLLVMType) IsStruct() bool <span class="cov0" title="0">{
        return typ.isStruct
}</span>

// MockLLVMBuilder implements LLVMBuilder for instruction generation
type MockLLVMBuilder struct {
        currentBlock interfaces.LLVMBasicBlock
        instructions []MockInstruction
}

type MockInstruction struct {
        opcode   string
        operands []string
        result   string
}

// NewMockLLVMBuilder creates a new mock LLVM builder
func NewMockLLVMBuilder() *MockLLVMBuilder <span class="cov0" title="0">{
        return &amp;MockLLVMBuilder{
                instructions: make([]MockInstruction, 0),
        }
}</span>

// PositionAtEnd positions the builder at the end of a basic block
func (builder *MockLLVMBuilder) PositionAtEnd(block interfaces.LLVMBasicBlock) <span class="cov0" title="0">{
        builder.currentBlock = block
}</span>

// CreateAlloca creates an alloca instruction
func (builder *MockLLVMBuilder) CreateAlloca(t interfaces.LLVMType, name string) interfaces.LLVMValue <span class="cov0" title="0">{
        instruction := MockInstruction{
                opcode: "alloca",
                result: name,
        }
        builder.instructions = append(builder.instructions, instruction)

        return &amp;MockLLVMValue{
                name: name,
                typ:  t,
        }
}</span>

// CreateStore creates a store instruction
func (builder *MockLLVMBuilder) CreateStore(value, ptr interfaces.LLVMValue) interfaces.LLVMValue <span class="cov0" title="0">{
        instruction := MockInstruction{
                opcode:   "store",
                operands: []string{value.GetName(), ptr.GetName()},
        }
        builder.instructions = append(builder.instructions, instruction)

        return nil // Store returns void
}</span>

// CreateLoad creates a load instruction
func (builder *MockLLVMBuilder) CreateLoad(ptr interfaces.LLVMValue, name string) interfaces.LLVMValue <span class="cov0" title="0">{
        instruction := MockInstruction{
                opcode:   "load",
                operands: []string{ptr.GetName()},
                result:   name,
        }
        builder.instructions = append(builder.instructions, instruction)

        return &amp;MockLLVMValue{
                name: name,
                typ:  ptr.GetType(),
        }
}</span>

// Implement other builder methods with similar mock patterns...
func (builder *MockLLVMBuilder) CreateAdd(lhs, rhs interfaces.LLVMValue, name string) interfaces.LLVMValue <span class="cov0" title="0">{
        instruction := MockInstruction{
                opcode:   "add",
                operands: []string{lhs.GetName(), rhs.GetName()},
                result:   name,
        }
        builder.instructions = append(builder.instructions, instruction)

        return &amp;MockLLVMValue{name: name, typ: lhs.GetType()}
}</span>

func (builder *MockLLVMBuilder) CreateSub(lhs, rhs interfaces.LLVMValue, name string) interfaces.LLVMValue <span class="cov0" title="0">{
        instruction := MockInstruction{
                opcode:   "sub",
                operands: []string{lhs.GetName(), rhs.GetName()},
                result:   name,
        }
        builder.instructions = append(builder.instructions, instruction)

        return &amp;MockLLVMValue{name: name, typ: lhs.GetType()}
}</span>

func (builder *MockLLVMBuilder) CreateMul(lhs, rhs interfaces.LLVMValue, name string) interfaces.LLVMValue <span class="cov0" title="0">{
        instruction := MockInstruction{
                opcode:   "mul",
                operands: []string{lhs.GetName(), rhs.GetName()},
                result:   name,
        }
        builder.instructions = append(builder.instructions, instruction)

        return &amp;MockLLVMValue{name: name, typ: lhs.GetType()}
}</span>

func (builder *MockLLVMBuilder) CreateSDiv(lhs, rhs interfaces.LLVMValue, name string) interfaces.LLVMValue <span class="cov0" title="0">{
        instruction := MockInstruction{
                opcode:   "sdiv",
                operands: []string{lhs.GetName(), rhs.GetName()},
                result:   name,
        }
        builder.instructions = append(builder.instructions, instruction)

        return &amp;MockLLVMValue{name: name, typ: lhs.GetType()}
}</span>

func (builder *MockLLVMBuilder) CreateICmp(pred interfaces.IntPredicate, lhs, rhs interfaces.LLVMValue, name string) interfaces.LLVMValue <span class="cov0" title="0">{
        instruction := MockInstruction{
                opcode:   fmt.Sprintf("icmp %d", int(pred)),
                operands: []string{lhs.GetName(), rhs.GetName()},
                result:   name,
        }
        builder.instructions = append(builder.instructions, instruction)

        // Return boolean type
        return &amp;MockLLVMValue{
                name: name,
                typ: &amp;MockLLVMType{
                        domainType: &amp;domain.BasicType{Kind: domain.BoolType},
                },
        }
}</span>

func (builder *MockLLVMBuilder) CreateFCmp(pred interfaces.FloatPredicate, lhs, rhs interfaces.LLVMValue, name string) interfaces.LLVMValue <span class="cov0" title="0">{
        instruction := MockInstruction{
                opcode:   fmt.Sprintf("fcmp %d", int(pred)),
                operands: []string{lhs.GetName(), rhs.GetName()},
                result:   name,
        }
        builder.instructions = append(builder.instructions, instruction)

        return &amp;MockLLVMValue{
                name: name,
                typ: &amp;MockLLVMType{
                        domainType: &amp;domain.BasicType{Kind: domain.BoolType},
                },
        }
}</span>

func (builder *MockLLVMBuilder) CreateBr(dest interfaces.LLVMBasicBlock) interfaces.LLVMValue <span class="cov0" title="0">{
        instruction := MockInstruction{
                opcode:   "br",
                operands: []string{dest.GetName()},
        }
        builder.instructions = append(builder.instructions, instruction)

        // Mark current block as terminated
        if mockBlock, ok := builder.currentBlock.(*MockLLVMBasicBlock); ok </span><span class="cov0" title="0">{
                mockBlock.terminated = true
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (builder *MockLLVMBuilder) CreateCondBr(cond interfaces.LLVMValue, then, else_ interfaces.LLVMBasicBlock) interfaces.LLVMValue <span class="cov0" title="0">{
        instruction := MockInstruction{
                opcode:   "br",
                operands: []string{cond.GetName(), then.GetName(), else_.GetName()},
        }
        builder.instructions = append(builder.instructions, instruction)

        // Mark current block as terminated
        if mockBlock, ok := builder.currentBlock.(*MockLLVMBasicBlock); ok </span><span class="cov0" title="0">{
                mockBlock.terminated = true
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (builder *MockLLVMBuilder) CreateRet(value interfaces.LLVMValue) interfaces.LLVMValue <span class="cov0" title="0">{
        instruction := MockInstruction{
                opcode:   "ret",
                operands: []string{value.GetName()},
        }
        builder.instructions = append(builder.instructions, instruction)

        // Mark current block as terminated
        if mockBlock, ok := builder.currentBlock.(*MockLLVMBasicBlock); ok </span><span class="cov0" title="0">{
                mockBlock.terminated = true
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (builder *MockLLVMBuilder) CreateRetVoid() interfaces.LLVMValue <span class="cov0" title="0">{
        instruction := MockInstruction{
                opcode: "ret void",
        }
        builder.instructions = append(builder.instructions, instruction)

        // Mark current block as terminated
        if mockBlock, ok := builder.currentBlock.(*MockLLVMBasicBlock); ok </span><span class="cov0" title="0">{
                mockBlock.terminated = true
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (builder *MockLLVMBuilder) CreateCall(fn interfaces.LLVMFunction, args []interfaces.LLVMValue, name string) interfaces.LLVMValue <span class="cov0" title="0">{
        operands := make([]string, len(args)+1)
        operands[0] = "@" + fn.(*MockLLVMFunction).name
        for i, arg := range args </span><span class="cov0" title="0">{
                operands[i+1] = arg.GetName()
        }</span>

        <span class="cov0" title="0">instruction := MockInstruction{
                opcode:   "call",
                operands: operands,
                result:   name,
        }
        builder.instructions = append(builder.instructions, instruction)

        // Return type based on function return type
        return &amp;MockLLVMValue{
                name: name,
                typ: &amp;MockLLVMType{
                        domainType: fn.(*MockLLVMFunction).funcType.ReturnType,
                },
        }</span>
}

func (builder *MockLLVMBuilder) CreateGEP(ptr interfaces.LLVMValue, indices []interfaces.LLVMValue, name string) interfaces.LLVMValue <span class="cov0" title="0">{
        operands := make([]string, len(indices)+1)
        operands[0] = ptr.GetName()
        for i, index := range indices </span><span class="cov0" title="0">{
                operands[i+1] = index.GetName()
        }</span>

        <span class="cov0" title="0">instruction := MockInstruction{
                opcode:   "getelementptr",
                operands: operands,
                result:   name,
        }
        builder.instructions = append(builder.instructions, instruction)

        return &amp;MockLLVMValue{
                name: name,
                typ:  ptr.GetType(), // Simplified - would be element type
        }</span>
}

func (builder *MockLLVMBuilder) Dispose() <span class="cov0" title="0">{
        builder.instructions = builder.instructions[:0]
        builder.currentBlock = nil
}</span>

// RealLLVMIRGenerator implements interfaces.CodeGenerator using the existing codegen.Generator
type RealLLVMIRGenerator struct {
        generator     *codegen.Generator
        output        io.Writer
        options       interfaces.CodeGenOptions
        errorReporter domain.ErrorReporter
}

// NewRealLLVMIRGenerator creates a new real LLVM IR generator
func NewRealLLVMIRGenerator() *RealLLVMIRGenerator <span class="cov0" title="0">{
        return &amp;RealLLVMIRGenerator{
                generator: codegen.NewGenerator(),
        }
}</span>

// Generate generates LLVM IR for the given AST using the real code generator
func (cg *RealLLVMIRGenerator) Generate(ast *domain.Program) error <span class="cov0" title="0">{
        if cg.output == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("output not set")
        }</span>

        // Generate LLVM IR using the existing codegen.Generator
        <span class="cov0" title="0">llvmIR, err := cg.generator.Generate(ast)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate LLVM IR: %v", err)
        }</span>

        // Write the generated LLVM IR to the output
        <span class="cov0" title="0">_, err = cg.output.Write([]byte(llvmIR))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write LLVM IR: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetOutput sets the output destination
func (cg *RealLLVMIRGenerator) SetOutput(output io.Writer) <span class="cov0" title="0">{
        cg.output = output
}</span>

// SetOptions sets code generation options
func (cg *RealLLVMIRGenerator) SetOptions(options interfaces.CodeGenOptions) <span class="cov0" title="0">{
        cg.options = options

        // Set the target triple in the generator if supported
        // The codegen.Generator currently uses a fixed target triple
        // but we could extend it to be configurable in the future
}</span>

// SetErrorReporter sets the error reporter
func (cg *RealLLVMIRGenerator) SetErrorReporter(reporter domain.ErrorReporter) <span class="cov0" title="0">{
        cg.errorReporter = reporter
        cg.generator.SetErrorReporter(reporter)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package infrastructure contains memory management implementation
package infrastructure

import (
        "fmt"
        "sync"
        "unsafe"

        "github.com/sokoide/llvm5/internal/interfaces"
)

// PooledMemoryManager implements MemoryManager using memory pools for efficiency
type PooledMemoryManager struct {
        mutex            sync.RWMutex
        nodePools        map[string]*nodePool
        stringPool       map[string]*stringEntry
        totalAllocated   int
        nodesAllocated   int
        stringsAllocated int
}

type nodePool struct {
        nodes []interface{}
        size  int
}

type stringEntry struct {
        value    string
        refCount int
}

// NewPooledMemoryManager creates a new pooled memory manager
func NewPooledMemoryManager() *PooledMemoryManager <span class="cov8" title="1">{
        return &amp;PooledMemoryManager{
                nodePools:  make(map[string]*nodePool),
                stringPool: make(map[string]*stringEntry),
        }
}</span>

// AllocateNode allocates memory for an AST node using type-specific pools
func (mm *PooledMemoryManager) AllocateNode(nodeType string, size int) (interface{}, error) <span class="cov8" title="1">{
        mm.mutex.Lock()
        defer mm.mutex.Unlock()

        pool, exists := mm.nodePools[nodeType]
        if !exists </span><span class="cov8" title="1">{
                pool = &amp;nodePool{
                        nodes: make([]interface{}, 0, 16), // Start with small capacity
                        size:  size,
                }
                mm.nodePools[nodeType] = pool
        }</span>

        // For simplicity, we'll allocate a new node each time
        // In a real implementation, you might want to reuse nodes from the pool
        <span class="cov8" title="1">var node interface{}

        switch nodeType </span>{
        case "LiteralExpr":<span class="cov0" title="0">
                node = &amp;struct{}{}</span> // Placeholder - would be actual node type
        case "BinaryExpr":<span class="cov0" title="0">
                node = &amp;struct{}{}</span> // Placeholder - would be actual node type
        case "IdentifierExpr":<span class="cov0" title="0">
                node = &amp;struct{}{}</span> // Placeholder - would be actual node type
        default:<span class="cov8" title="1">
                node = make([]byte, size)</span> // Generic allocation
        }

        <span class="cov8" title="1">pool.nodes = append(pool.nodes, node)
        mm.nodesAllocated++
        mm.totalAllocated += size

        return node, nil</span>
}

// AllocateString allocates memory for a string with reference counting
func (mm *PooledMemoryManager) AllocateString(s string) (interface{}, error) <span class="cov8" title="1">{
        mm.mutex.Lock()
        defer mm.mutex.Unlock()

        if entry, exists := mm.stringPool[s]; exists </span><span class="cov0" title="0">{
                entry.refCount++
                return entry.value, nil
        }</span>

        <span class="cov8" title="1">entry := &amp;stringEntry{
                value:    s,
                refCount: 1,
        }

        mm.stringPool[s] = entry
        mm.stringsAllocated++
        mm.totalAllocated += len(s)

        return entry.value, nil</span>
}

// ReleaseString decrements the reference count for a string
func (mm *PooledMemoryManager) ReleaseString(s string) <span class="cov0" title="0">{
        mm.mutex.Lock()
        defer mm.mutex.Unlock()

        if entry, exists := mm.stringPool[s]; exists </span><span class="cov0" title="0">{
                entry.refCount--
                if entry.refCount &lt;= 0 </span><span class="cov0" title="0">{
                        mm.totalAllocated -= len(s)
                        delete(mm.stringPool, s)
                }</span>
        }
}

// FreeAll frees all allocated memory
func (mm *PooledMemoryManager) FreeAll() <span class="cov8" title="1">{
        mm.mutex.Lock()
        defer mm.mutex.Unlock()

        // Clear node pools
        for nodeType := range mm.nodePools </span><span class="cov8" title="1">{
                delete(mm.nodePools, nodeType)
        }</span>

        // Clear string pool
        <span class="cov8" title="1">for s := range mm.stringPool </span><span class="cov8" title="1">{
                delete(mm.stringPool, s)
        }</span>

        <span class="cov8" title="1">mm.totalAllocated = 0
        mm.nodesAllocated = 0
        mm.stringsAllocated = 0</span>
}

// GetStats returns memory usage statistics
func (mm *PooledMemoryManager) GetStats() interfaces.MemoryStats <span class="cov8" title="1">{
        mm.mutex.RLock()
        defer mm.mutex.RUnlock()

        return interfaces.MemoryStats{
                NodesAllocated:   mm.nodesAllocated,
                StringsAllocated: mm.stringsAllocated,
                TotalMemoryUsed:  mm.totalAllocated,
        }
}</span>

// GetPoolStats returns detailed statistics about memory pools
func (mm *PooledMemoryManager) GetPoolStats() map[string]int <span class="cov0" title="0">{
        mm.mutex.RLock()
        defer mm.mutex.RUnlock()

        stats := make(map[string]int)
        for nodeType, pool := range mm.nodePools </span><span class="cov0" title="0">{
                stats[nodeType] = len(pool.nodes)
        }</span>
        <span class="cov0" title="0">return stats</span>
}

// CompactMemoryManager is a simpler memory manager that doesn't use pools
type CompactMemoryManager struct {
        mutex       sync.RWMutex
        allocations []allocation
        totalMemory int
}

type allocation struct {
        ptr        interface{}
        size       int
        objectType string
}

// NewCompactMemoryManager creates a new compact memory manager
func NewCompactMemoryManager() *CompactMemoryManager <span class="cov8" title="1">{
        return &amp;CompactMemoryManager{
                allocations: make([]allocation, 0),
        }
}</span>

// AllocateNode allocates memory for an AST node
func (mm *CompactMemoryManager) AllocateNode(nodeType string, size int) (interface{}, error) <span class="cov8" title="1">{
        mm.mutex.Lock()
        defer mm.mutex.Unlock()

        // Allocate the requested memory
        ptr := make([]byte, size)

        allocation := allocation{
                ptr:        ptr,
                size:       size,
                objectType: nodeType,
        }

        mm.allocations = append(mm.allocations, allocation)
        mm.totalMemory += size

        return ptr, nil
}</span>

// AllocateString allocates memory for a string
func (mm *CompactMemoryManager) AllocateString(s string) (interface{}, error) <span class="cov8" title="1">{
        mm.mutex.Lock()
        defer mm.mutex.Unlock()

        size := len(s)
        allocation := allocation{
                ptr:        s,
                size:       size,
                objectType: "string",
        }

        mm.allocations = append(mm.allocations, allocation)
        mm.totalMemory += size

        return s, nil
}</span>

// FreeAll frees all allocated memory
func (mm *CompactMemoryManager) FreeAll() <span class="cov8" title="1">{
        mm.mutex.Lock()
        defer mm.mutex.Unlock()

        mm.allocations = mm.allocations[:0]
        mm.totalMemory = 0
}</span>

// GetStats returns memory usage statistics
func (mm *CompactMemoryManager) GetStats() interfaces.MemoryStats <span class="cov8" title="1">{
        mm.mutex.RLock()
        defer mm.mutex.RUnlock()

        nodeCount := 0
        stringCount := 0

        for _, alloc := range mm.allocations </span><span class="cov0" title="0">{
                switch alloc.objectType </span>{
                case "string":<span class="cov0" title="0">
                        stringCount++</span>
                default:<span class="cov0" title="0">
                        nodeCount++</span>
                }
        }

        <span class="cov8" title="1">return interfaces.MemoryStats{
                NodesAllocated:   nodeCount,
                StringsAllocated: stringCount,
                TotalMemoryUsed:  mm.totalMemory,
        }</span>
}

// TrackingMemoryManager wraps another MemoryManager and provides detailed tracking
type TrackingMemoryManager struct {
        underlying    interfaces.MemoryManager
        allocationLog []AllocationEvent
        mutex         sync.RWMutex
}

type AllocationEvent struct {
        Type      string
        Size      int
        Timestamp int64
        Action    string // "allocate" or "free"
}

// NewTrackingMemoryManager creates a new tracking memory manager
func NewTrackingMemoryManager(underlying interfaces.MemoryManager) *TrackingMemoryManager <span class="cov8" title="1">{
        return &amp;TrackingMemoryManager{
                underlying:    underlying,
                allocationLog: make([]AllocationEvent, 0),
        }
}</span>

// AllocateNode allocates memory for an AST node and logs the allocation
func (mm *TrackingMemoryManager) AllocateNode(nodeType string, size int) (interface{}, error) <span class="cov8" title="1">{
        result, err := mm.underlying.AllocateNode(nodeType, size)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">mm.mutex.Lock()
        mm.allocationLog = append(mm.allocationLog, AllocationEvent{
                Type:   nodeType,
                Size:   size,
                Action: "allocate",
        })
        mm.mutex.Unlock()

        return result, nil</span>
}

// AllocateString allocates memory for a string and logs the allocation
func (mm *TrackingMemoryManager) AllocateString(s string) (interface{}, error) <span class="cov8" title="1">{
        result, err := mm.underlying.AllocateString(s)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">mm.mutex.Lock()
        mm.allocationLog = append(mm.allocationLog, AllocationEvent{
                Type:   "string",
                Size:   len(s),
                Action: "allocate",
        })
        mm.mutex.Unlock()

        return result, nil</span>
}

// FreeAll frees all allocated memory and logs the event
func (mm *TrackingMemoryManager) FreeAll() <span class="cov8" title="1">{
        mm.underlying.FreeAll()

        mm.mutex.Lock()
        mm.allocationLog = append(mm.allocationLog, AllocationEvent{
                Type:   "all",
                Size:   0,
                Action: "free",
        })
        mm.mutex.Unlock()
}</span>

// GetStats returns memory usage statistics
func (mm *TrackingMemoryManager) GetStats() interfaces.MemoryStats <span class="cov8" title="1">{
        return mm.underlying.GetStats()
}</span>

// GetAllocationLog returns the allocation log
func (mm *TrackingMemoryManager) GetAllocationLog() []AllocationEvent <span class="cov8" title="1">{
        mm.mutex.RLock()
        defer mm.mutex.RUnlock()

        log := make([]AllocationEvent, len(mm.allocationLog))
        copy(log, mm.allocationLog)
        return log
}</span>

// PrintMemoryReport prints a detailed memory usage report
func (mm *TrackingMemoryManager) PrintMemoryReport() <span class="cov8" title="1">{
        mm.mutex.RLock()
        defer mm.mutex.RUnlock()

        stats := mm.GetStats()
        fmt.Printf("Memory Usage Report:\n")
        fmt.Printf("  Nodes Allocated: %d\n", stats.NodesAllocated)
        fmt.Printf("  Strings Allocated: %d\n", stats.StringsAllocated)
        fmt.Printf("  Total Memory Used: %d bytes\n", stats.TotalMemoryUsed)
        fmt.Printf("  Total Allocation Events: %d\n", len(mm.allocationLog))

        // Count allocations by type
        typeCounts := make(map[string]int)
        for _, event := range mm.allocationLog </span><span class="cov8" title="1">{
                if event.Action == "allocate" </span><span class="cov8" title="1">{
                        typeCounts[event.Type]++
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("  Allocations by Type:\n")
        for nodeType, count := range typeCounts </span><span class="cov8" title="1">{
                fmt.Printf("    %s: %d\n", nodeType, count)
        }</span>
}

// GetMemorySize returns the size in bytes of a given object
func GetMemorySize(obj interface{}) int <span class="cov0" title="0">{
        return int(unsafe.Sizeof(obj))
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package infrastructure contains implementations of infrastructure concerns
package infrastructure

import (
        "fmt"

        "github.com/sokoide/llvm5/internal/domain"
        "github.com/sokoide/llvm5/internal/interfaces"
)

// DefaultSymbolTable implements the SymbolTable interface
type DefaultSymbolTable struct {
        currentScope *interfaces.Scope
        globalScope  *interfaces.Scope
}

// NewDefaultSymbolTable creates a new symbol table with a global scope
func NewDefaultSymbolTable() *DefaultSymbolTable <span class="cov8" title="1">{
        globalScope := &amp;interfaces.Scope{
                Parent:   nil,
                Symbols:  make(map[string]*interfaces.Symbol),
                Children: make([]*interfaces.Scope, 0),
                Level:    0,
        }

        return &amp;DefaultSymbolTable{
                currentScope: globalScope,
                globalScope:  globalScope,
        }
}</span>

// NewSymbolTable creates a new symbol table
func NewSymbolTable() interfaces.SymbolTable <span class="cov8" title="1">{
        return NewDefaultSymbolTable()
}</span>

// EnterScope creates a new scope as a child of the current scope
func (st *DefaultSymbolTable) EnterScope() *interfaces.Scope <span class="cov8" title="1">{
        newScope := &amp;interfaces.Scope{
                Parent:   st.currentScope,
                Symbols:  make(map[string]*interfaces.Symbol),
                Children: make([]*interfaces.Scope, 0),
                Level:    st.currentScope.Level + 1,
        }

        st.currentScope.Children = append(st.currentScope.Children, newScope)
        st.currentScope = newScope

        return newScope
}</span>

// ExitScope exits the current scope and returns to the parent scope
func (st *DefaultSymbolTable) ExitScope() <span class="cov8" title="1">{
        if st.currentScope.Parent != nil </span><span class="cov8" title="1">{
                st.currentScope = st.currentScope.Parent
        }</span>
}

// GetCurrentScope returns the current scope
func (st *DefaultSymbolTable) GetCurrentScope() *interfaces.Scope <span class="cov8" title="1">{
        return st.currentScope
}</span>

// DeclareSymbol declares a new symbol in the current scope
func (st *DefaultSymbolTable) DeclareSymbol(name string, symbolType domain.Type, kind interfaces.SymbolKind, location domain.SourceRange) (*interfaces.Symbol, error) <span class="cov8" title="1">{
        // Check if symbol already exists in current scope
        if _, exists := st.currentScope.Symbols[name]; exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("symbol '%s' already declared in current scope", name)
        }</span>

        <span class="cov8" title="1">symbol := &amp;interfaces.Symbol{
                Name:     name,
                Type:     symbolType,
                Kind:     kind,
                Location: location,
                Scope:    st.currentScope,
        }

        st.currentScope.Symbols[name] = symbol
        return symbol, nil</span>
}

// LookupSymbol looks up a symbol in the current scope chain
func (st *DefaultSymbolTable) LookupSymbol(name string) (*interfaces.Symbol, bool) <span class="cov8" title="1">{
        scope := st.currentScope
        for scope != nil </span><span class="cov8" title="1">{
                if symbol, exists := scope.Symbols[name]; exists </span><span class="cov8" title="1">{
                        return symbol, true
                }</span>
                <span class="cov8" title="1">scope = scope.Parent</span>
        }
        <span class="cov8" title="1">return nil, false</span>
}

// LookupSymbolInScope looks up a symbol in a specific scope only
func (st *DefaultSymbolTable) LookupSymbolInScope(name string, scope *interfaces.Scope) (*interfaces.Symbol, bool) <span class="cov8" title="1">{
        symbol, exists := scope.Symbols[name]
        return symbol, exists
}</span>

// GetGlobalScope returns the global scope
func (st *DefaultSymbolTable) GetGlobalScope() *interfaces.Scope <span class="cov8" title="1">{
        return st.globalScope
}</span>

// GetSymbolsInScope returns all symbols in the given scope
func (st *DefaultSymbolTable) GetSymbolsInScope(scope *interfaces.Scope) []*interfaces.Symbol <span class="cov8" title="1">{
        symbols := make([]*interfaces.Symbol, 0, len(scope.Symbols))
        for _, symbol := range scope.Symbols </span><span class="cov8" title="1">{
                symbols = append(symbols, symbol)
        }</span>
        <span class="cov8" title="1">return symbols</span>
}

// GetAllSymbols returns all symbols in all scopes
func (st *DefaultSymbolTable) GetAllSymbols() []*interfaces.Symbol <span class="cov8" title="1">{
        var symbols []*interfaces.Symbol
        st.collectSymbolsFromScope(st.globalScope, &amp;symbols)
        return symbols
}</span>

func (st *DefaultSymbolTable) collectSymbolsFromScope(scope *interfaces.Scope, symbols *[]*interfaces.Symbol) <span class="cov8" title="1">{
        for _, symbol := range scope.Symbols </span><span class="cov8" title="1">{
                *symbols = append(*symbols, symbol)
        }</span>
        <span class="cov8" title="1">for _, child := range scope.Children </span><span class="cov8" title="1">{
                st.collectSymbolsFromScope(child, symbols)
        }</span>
}

// Reset resets the symbol table to its initial state
func (st *DefaultSymbolTable) Reset() <span class="cov8" title="1">{
        st.globalScope = &amp;interfaces.Scope{
                Parent:   nil,
                Symbols:  make(map[string]*interfaces.Symbol),
                Children: make([]*interfaces.Scope, 0),
                Level:    0,
        }
        st.currentScope = st.globalScope
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package interfaces defines the core interfaces for the StaticLang compiler components
package interfaces

import (
        "io"

        "github.com/sokoide/llvm5/internal/domain"
)

// Token represents a lexical token
type Token struct {
        Type     TokenType
        Value    string
        Location domain.SourcePosition
}

type TokenType int

const (
        // Literals
        TokenInt TokenType = iota
        TokenFloat
        TokenString
        TokenBool
        TokenIdentifier

        // Keywords
        TokenFunc
        TokenStruct
        TokenVar
        TokenIf
        TokenElse
        TokenWhile
        TokenFor
        TokenReturn
        TokenTrue
        TokenFalse

        // Operators
        TokenPlus
        TokenMinus
        TokenStar
        TokenSlash
        TokenPercent
        TokenEqual
        TokenNotEqual
        TokenLess
        TokenLessEqual
        TokenGreater
        TokenGreaterEqual
        TokenAnd
        TokenOr
        TokenNot
        TokenAssign

        // Delimiters
        TokenLeftParen
        TokenRightParen
        TokenLeftBrace
        TokenRightBrace
        TokenLeftBracket
        TokenRightBracket
        TokenSemicolon
        TokenComma
        TokenDot
        TokenColon
        TokenArrow

        // Special
                TokenEOF
                TokenError
        )

        // String returns the string representation of the token type
        func (tt TokenType) String() string <span class="cov8" title="1">{
                switch tt </span>{
                case TokenEOF:<span class="cov8" title="1">
                        return "EOF"</span>
                case TokenError:<span class="cov8" title="1">
                        return "Error"</span>
                case TokenIdentifier:<span class="cov8" title="1">
                        return "Identifier"</span>
                case TokenInt:<span class="cov8" title="1">
                        return "Int"</span>
                case TokenFloat:<span class="cov8" title="1">
                        return "Float"</span>
                case TokenString:<span class="cov8" title="1">
                        return "String"</span>
                case TokenBool:<span class="cov8" title="1">
                        return "Bool"</span>
                case TokenTrue:<span class="cov8" title="1">
                        return "True"</span>
                case TokenFalse:<span class="cov8" title="1">
                        return "False"</span>
                case TokenFunc:<span class="cov8" title="1">
                        return "Func"</span>
                case TokenStruct:<span class="cov8" title="1">
                        return "Struct"</span>
                case TokenVar:<span class="cov8" title="1">
                        return "Var"</span>
                case TokenIf:<span class="cov8" title="1">
                        return "If"</span>
                case TokenElse:<span class="cov8" title="1">
                        return "Else"</span>
                case TokenWhile:<span class="cov8" title="1">
                        return "While"</span>
                case TokenFor:<span class="cov8" title="1">
                        return "For"</span>
                case TokenReturn:<span class="cov8" title="1">
                        return "Return"</span>
                case TokenPlus:<span class="cov8" title="1">
                        return "Plus"</span>
                case TokenMinus:<span class="cov8" title="1">
                        return "Minus"</span>
                case TokenStar:<span class="cov8" title="1">
                        return "Star"</span>
                case TokenSlash:<span class="cov8" title="1">
                        return "Slash"</span>
                case TokenPercent:<span class="cov8" title="1">
                        return "Percent"</span>
                case TokenEqual:<span class="cov8" title="1">
                        return "Equal"</span>
                case TokenNotEqual:<span class="cov8" title="1">
                        return "NotEqual"</span>
                case TokenLess:<span class="cov8" title="1">
                        return "Less"</span>
                case TokenLessEqual:<span class="cov8" title="1">
                        return "LessEqual"</span>
                case TokenGreater:<span class="cov8" title="1">
                        return "Greater"</span>
                case TokenGreaterEqual:<span class="cov8" title="1">
                        return "GreaterEqual"</span>
                case TokenAnd:<span class="cov8" title="1">
                        return "And"</span>
                case TokenOr:<span class="cov8" title="1">
                        return "Or"</span>
                case TokenNot:<span class="cov8" title="1">
                        return "Not"</span>
                case TokenAssign:<span class="cov8" title="1">
                        return "Assign"</span>
                case TokenLeftParen:<span class="cov8" title="1">
                        return "LeftParen"</span>
                case TokenRightParen:<span class="cov8" title="1">
                        return "RightParen"</span>
                case TokenLeftBrace:<span class="cov8" title="1">
                        return "LeftBrace"</span>
                case TokenRightBrace:<span class="cov8" title="1">
                        return "RightBrace"</span>
                case TokenLeftBracket:<span class="cov8" title="1">
                        return "LeftBracket"</span>
                case TokenRightBracket:<span class="cov8" title="1">
                        return "RightBracket"</span>
                case TokenSemicolon:<span class="cov8" title="1">
                        return "Semicolon"</span>
                case TokenComma:<span class="cov8" title="1">
                        return "Comma"</span>
                case TokenDot:<span class="cov8" title="1">
                        return "Dot"</span>
                case TokenArrow:<span class="cov8" title="1">
                        return "Arrow"</span>
                case TokenColon:<span class="cov8" title="1">
                        return "Colon"</span>
                default:<span class="cov0" title="0">
                        return "Unknown"</span>
                }
        }

// Lexer interface defines the lexical analyzer
type Lexer interface {
        // NextToken returns the next token from the input
        NextToken() Token

        // Peek returns the next token without consuming it
        Peek() Token

        // SetInput sets the input source for lexing
        SetInput(filename string, input io.Reader) error

        // GetCurrentPosition returns the current position in the input
        GetCurrentPosition() domain.SourcePosition
}

// Parser interface defines the syntax analyzer
type Parser interface {
        // Parse parses the input and returns an AST
        Parse(lexer Lexer) (*domain.Program, error)

        // SetErrorReporter sets the error reporter for the parser
        SetErrorReporter(reporter domain.ErrorReporter)
}

// SemanticAnalyzer interface defines the semantic analyzer
type SemanticAnalyzer interface {
        // Analyze performs semantic analysis on the AST
        Analyze(ast *domain.Program) error

        // SetTypeRegistry sets the type registry
        SetTypeRegistry(registry domain.TypeRegistry)

        // SetSymbolTable sets the symbol table
        SetSymbolTable(symbolTable SymbolTable)

        // SetErrorReporter sets the error reporter
        SetErrorReporter(reporter domain.ErrorReporter)
}

// CodeGenerator interface defines the code generator
type CodeGenerator interface {
        // Generate generates code for the given AST
        Generate(ast *domain.Program) error

        // SetOutput sets the output destination
        SetOutput(output io.Writer)

        // SetOptions sets code generation options
        SetOptions(options CodeGenOptions)

        // SetErrorReporter sets the error reporter
        SetErrorReporter(reporter domain.ErrorReporter)
}

// CodeGenOptions holds code generation configuration
type CodeGenOptions struct {
        OptimizationLevel int
        DebugInfo         bool
        TargetTriple      string
}

// Symbol represents a symbol in the symbol table
type Symbol struct {
        Name     string
        Type     domain.Type
        Kind     SymbolKind
        Location domain.SourceRange
        Scope    *Scope
}

type SymbolKind int

const (
        VariableSymbol SymbolKind = iota
        FunctionSymbol
        ParameterSymbol
        StructSymbol
        FieldSymbol
)

// Scope represents a lexical scope
type Scope struct {
        Parent   *Scope
        Symbols  map[string]*Symbol
        Children []*Scope
        Level    int
}

// SymbolTable interface defines symbol table operations
type SymbolTable interface {
        // EnterScope creates a new scope
        EnterScope() *Scope

        // ExitScope exits the current scope
        ExitScope()

        // GetCurrentScope returns the current scope
        GetCurrentScope() *Scope

        // DeclareSymbol declares a symbol in the current scope
        DeclareSymbol(name string, symbolType domain.Type, kind SymbolKind, location domain.SourceRange) (*Symbol, error)

        // LookupSymbol looks up a symbol in the current scope chain
        LookupSymbol(name string) (*Symbol, bool)

        // LookupSymbolInScope looks up a symbol in a specific scope only
        LookupSymbolInScope(name string, scope *Scope) (*Symbol, bool)
}

// MemoryManager interface defines memory management operations
type MemoryManager interface {
        // AllocateNode allocates memory for an AST node
        AllocateNode(nodeType string, size int) (interface{}, error)

        // AllocateString allocates memory for a string
        AllocateString(s string) (interface{}, error)

        // FreeAll frees all allocated memory
        FreeAll()

        // GetStats returns memory usage statistics
        GetStats() MemoryStats
}

type MemoryStats struct {
        NodesAllocated   int
        StringsAllocated int
        TotalMemoryUsed  int
}

// CompilerPipeline interface defines the overall compilation process
type CompilerPipeline interface {
        // Compile compiles a source file through the entire pipeline
        Compile(filename string, input io.Reader, output io.Writer) error

        // SetLexer sets the lexer implementation
        SetLexer(lexer Lexer)

        // SetParser sets the parser implementation
        SetParser(parser Parser)

        // SetSemanticAnalyzer sets the semantic analyzer implementation
        SetSemanticAnalyzer(analyzer SemanticAnalyzer)

        // SetCodeGenerator sets the code generator implementation
        SetCodeGenerator(generator CodeGenerator)

        // SetErrorReporter sets the error reporter
        SetErrorReporter(reporter domain.ErrorReporter)

        // SetOptions sets compilation options
        SetOptions(options domain.CompilationOptions)
}

// LLVMBackend interface defines the LLVM abstraction layer
type LLVMBackend interface {
        // Initialize initializes the LLVM backend
        Initialize(targetTriple string) error

        // CreateModule creates a new LLVM module
        CreateModule(name string) (LLVMModule, error)

        // Optimize optimizes the given module
        Optimize(module LLVMModule, level int) error

        // EmitObject emits object code to the writer
        EmitObject(module LLVMModule, output io.Writer) error

        // EmitAssembly emits assembly code to the writer
        EmitAssembly(module LLVMModule, output io.Writer) error

        // Dispose disposes of resources
        Dispose()
}

// LLVMModule interface represents an LLVM module
type LLVMModule interface {
        // CreateFunction creates a new function in the module
        CreateFunction(name string, funcType domain.Type) (LLVMFunction, error)

        // CreateGlobalVariable creates a global variable
        CreateGlobalVariable(name string, varType domain.Type) (LLVMValue, error)

        // CreateStruct creates a struct type
        CreateStruct(name string, structType *domain.StructType) (LLVMType, error)

        // GetFunction gets a function by name
        GetFunction(name string) (LLVMFunction, bool)

        // Verify verifies the module
        Verify() error

        // Print prints the module IR
        Print(output io.Writer)

        // Dispose disposes of the module
        Dispose()
}

// LLVMFunction interface represents an LLVM function
type LLVMFunction interface {
        // CreateBasicBlock creates a basic block in the function
        CreateBasicBlock(name string) LLVMBasicBlock

        // GetParameter gets a parameter by index
        GetParameter(index int) LLVMValue

        // GetParameterCount gets the number of parameters
        GetParameterCount() int

        // SetName sets the function name
        SetName(name string)
}

// LLVMBasicBlock interface represents an LLVM basic block
type LLVMBasicBlock interface {
        // GetName gets the block name
        GetName() string

        // IsTerminated checks if the block is terminated
        IsTerminated() bool
}

// LLVMValue interface represents an LLVM value
type LLVMValue interface {
        // GetType gets the value type
        GetType() LLVMType

        // SetName sets the value name
        SetName(name string)

        // GetName gets the value name
        GetName() string
}

// LLVMType interface represents an LLVM type
type LLVMType interface {
        // IsInteger checks if the type is an integer
        IsInteger() bool

        // IsFloat checks if the type is a float
        IsFloat() bool

        // IsPointer checks if the type is a pointer
        IsPointer() bool

        // IsStruct checks if the type is a struct
        IsStruct() bool
}

// LLVMBuilder interface represents an LLVM IR builder
type LLVMBuilder interface {
        // PositionAtEnd positions the builder at the end of a basic block
        PositionAtEnd(block LLVMBasicBlock)

        // CreateAlloca creates an alloca instruction
        CreateAlloca(t LLVMType, name string) LLVMValue

        // CreateStore creates a store instruction
        CreateStore(value, ptr LLVMValue) LLVMValue

        // CreateLoad creates a load instruction
        CreateLoad(ptr LLVMValue, name string) LLVMValue

        // CreateAdd creates an add instruction
        CreateAdd(lhs, rhs LLVMValue, name string) LLVMValue

        // CreateSub creates a sub instruction
        CreateSub(lhs, rhs LLVMValue, name string) LLVMValue

        // CreateMul creates a mul instruction
        CreateMul(lhs, rhs LLVMValue, name string) LLVMValue

        // CreateSDiv creates a signed division instruction
        CreateSDiv(lhs, rhs LLVMValue, name string) LLVMValue

        // CreateICmp creates an integer comparison
        CreateICmp(pred IntPredicate, lhs, rhs LLVMValue, name string) LLVMValue

        // CreateFCmp creates a float comparison
        CreateFCmp(pred FloatPredicate, lhs, rhs LLVMValue, name string) LLVMValue

        // CreateBr creates an unconditional branch
        CreateBr(dest LLVMBasicBlock) LLVMValue

        // CreateCondBr creates a conditional branch
        CreateCondBr(cond LLVMValue, then, else_ LLVMBasicBlock) LLVMValue

        // CreateRet creates a return instruction
        CreateRet(value LLVMValue) LLVMValue

        // CreateRetVoid creates a void return instruction
        CreateRetVoid() LLVMValue

        // CreateCall creates a function call
        CreateCall(fn LLVMFunction, args []LLVMValue, name string) LLVMValue

        // CreateGEP creates a getelementptr instruction
        CreateGEP(ptr LLVMValue, indices []LLVMValue, name string) LLVMValue

        // Dispose disposes of the builder
        Dispose()
}

// IntPredicate represents integer comparison predicates
type IntPredicate int

const (
        IntEQ  IntPredicate = iota // equal
        IntNE                      // not equal
        IntSLT                     // signed less than
        IntSLE                     // signed less or equal
        IntSGT                     // signed greater than
        IntSGE                     // signed greater or equal
)

// FloatPredicate represents float comparison predicates
type FloatPredicate int

const (
        FloatOEQ FloatPredicate = iota // ordered and equal
        FloatONE                       // ordered and not equal
        FloatOLT                       // ordered and less than
        FloatOLE                       // ordered and less than or equal
        FloatOGT                       // ordered and greater than
        FloatOGE                       // ordered and greater than or equal
)
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package lexer provides lexical analysis for the StaticLang compiler
package lexer

import (
        "bufio"
        "fmt"
        "io"
        "strconv"
        "strings"
        "unicode"

        "github.com/sokoide/llvm5/internal/domain"
        "github.com/sokoide/llvm5/internal/interfaces"
)

// StaticLangLexer implements the Lexer interface for StaticLang
type StaticLangLexer struct {
        input       *bufio.Reader
        filename    string
        line        int
        column      int
        offset      int
        current     rune
        next        rune
        hasNext     bool
        peekedToken *interfaces.Token
}

// Keywords maps keyword strings to their token types
var keywords = map[string]interfaces.TokenType{
        "func":     interfaces.TokenFunc,
        "function": interfaces.TokenFunc, // Alternative syntax
        "struct":   interfaces.TokenStruct,
        "var":      interfaces.TokenVar,
        "if":       interfaces.TokenIf,
        "else":     interfaces.TokenElse,
        "while":    interfaces.TokenWhile,
        "for":      interfaces.TokenFor,
        "return":   interfaces.TokenReturn,
        "true":     interfaces.TokenTrue,
        "false":    interfaces.TokenFalse,
        // Type names like "int", "double", "string", "bool" should be identifiers
        // resolved by the type system, not special tokens
        "print": interfaces.TokenIdentifier, // Built-in function
}

// NewLexer creates a new StaticLang lexer
func NewLexer() *StaticLangLexer <span class="cov8" title="1">{
        return &amp;StaticLangLexer{
                line:   1,
                column: 0,
                offset: 0,
        }
}</span>

// SetInput sets the input source for lexing
func (l *StaticLangLexer) SetInput(filename string, input io.Reader) error <span class="cov8" title="1">{
        l.filename = filename
        l.input = bufio.NewReader(input)
        l.line = 1
        l.column = 0
        l.offset = 0
        l.peekedToken = nil

        // Read the first two characters
        if err := l.readChar(); err != nil </span><span class="cov0" title="0">{
                if err != io.EOF </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read input: %w", err)
                }</span>
                <span class="cov0" title="0">l.current = 0</span>
        }
        <span class="cov8" title="1">if err := l.readChar(); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read input: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// NextToken returns the next token from the input
func (l *StaticLangLexer) NextToken() interfaces.Token <span class="cov8" title="1">{
        if l.peekedToken != nil </span><span class="cov8" title="1">{
                token := *l.peekedToken
                l.peekedToken = nil
                return token
        }</span>

        <span class="cov8" title="1">l.skipWhitespace()

        position := l.getCurrentPosition()

        if l.current == 0 </span><span class="cov8" title="1">{
                return interfaces.Token{
                        Type:     interfaces.TokenEOF,
                        Value:    "",
                        Location: position,
                }
        }</span>

        // Single-character tokens
        <span class="cov8" title="1">switch l.current </span>{
        case '+':<span class="cov8" title="1">
                l.advance()
                return interfaces.Token{Type: interfaces.TokenPlus, Value: "+", Location: position}</span>
        case '-':<span class="cov8" title="1">
                if l.next == '&gt;' </span><span class="cov8" title="1">{
                        l.advance()
                        l.advance()
                        return interfaces.Token{Type: interfaces.TokenArrow, Value: "-&gt;", Location: position}
                }</span>
                <span class="cov8" title="1">l.advance()
                return interfaces.Token{Type: interfaces.TokenMinus, Value: "-", Location: position}</span>
        case '*':<span class="cov8" title="1">
                l.advance()
                return interfaces.Token{Type: interfaces.TokenStar, Value: "*", Location: position}</span>
        case '/':<span class="cov8" title="1">
                if l.next == '/' </span><span class="cov8" title="1">{
                        // Single-line comment, skip to end of line
                        l.skipComment()
                        return l.NextToken() // Get next token after comment
                }</span>
                <span class="cov8" title="1">l.advance()
                return interfaces.Token{Type: interfaces.TokenSlash, Value: "/", Location: position}</span>
        case '%':<span class="cov8" title="1">
                l.advance()
                return interfaces.Token{Type: interfaces.TokenPercent, Value: "%", Location: position}</span>
        case '(':<span class="cov8" title="1">
                l.advance()
                return interfaces.Token{Type: interfaces.TokenLeftParen, Value: "(", Location: position}</span>
        case ')':<span class="cov8" title="1">
                l.advance()
                return interfaces.Token{Type: interfaces.TokenRightParen, Value: ")", Location: position}</span>
        case '{':<span class="cov8" title="1">
                l.advance()
                return interfaces.Token{Type: interfaces.TokenLeftBrace, Value: "{", Location: position}</span>
        case '}':<span class="cov8" title="1">
                l.advance()
                return interfaces.Token{Type: interfaces.TokenRightBrace, Value: "}", Location: position}</span>
        case '[':<span class="cov8" title="1">
                l.advance()
                return interfaces.Token{Type: interfaces.TokenLeftBracket, Value: "[", Location: position}</span>
        case ']':<span class="cov8" title="1">
                l.advance()
                return interfaces.Token{Type: interfaces.TokenRightBracket, Value: "]", Location: position}</span>
        case ';':<span class="cov8" title="1">
                l.advance()
                return interfaces.Token{Type: interfaces.TokenSemicolon, Value: ";", Location: position}</span>
        case ',':<span class="cov8" title="1">
                l.advance()
                return interfaces.Token{Type: interfaces.TokenComma, Value: ",", Location: position}</span>
        case '.':<span class="cov8" title="1">
                l.advance()
                return interfaces.Token{Type: interfaces.TokenDot, Value: ".", Location: position}</span>
        case ':':<span class="cov8" title="1">
                l.advance()
                return interfaces.Token{Type: interfaces.TokenColon, Value: ":", Location: position}</span>
        }

        // Two-character tokens
        <span class="cov8" title="1">switch l.current </span>{
        case '=':<span class="cov8" title="1">
                if l.next == '=' </span><span class="cov8" title="1">{
                        l.advance()
                        l.advance()
                        return interfaces.Token{Type: interfaces.TokenEqual, Value: "==", Location: position}
                }</span>
                <span class="cov8" title="1">l.advance()
                return interfaces.Token{Type: interfaces.TokenAssign, Value: "=", Location: position}</span>
        case '!':<span class="cov8" title="1">
                if l.next == '=' </span><span class="cov8" title="1">{
                        l.advance()
                        l.advance()
                        return interfaces.Token{Type: interfaces.TokenNotEqual, Value: "!=", Location: position}
                }</span>
                <span class="cov8" title="1">l.advance()
                return interfaces.Token{Type: interfaces.TokenNot, Value: "!", Location: position}</span>
        case '&lt;':<span class="cov8" title="1">
                if l.next == '=' </span><span class="cov8" title="1">{
                        l.advance()
                        l.advance()
                        return interfaces.Token{Type: interfaces.TokenLessEqual, Value: "&lt;=", Location: position}
                }</span>
                <span class="cov8" title="1">l.advance()
                return interfaces.Token{Type: interfaces.TokenLess, Value: "&lt;", Location: position}</span>
        case '&gt;':<span class="cov8" title="1">
                if l.next == '=' </span><span class="cov8" title="1">{
                        l.advance()
                        l.advance()
                        return interfaces.Token{Type: interfaces.TokenGreaterEqual, Value: "&gt;=", Location: position}
                }</span>
                <span class="cov8" title="1">l.advance()
                return interfaces.Token{Type: interfaces.TokenGreater, Value: "&gt;", Location: position}</span>
        case '&amp;':<span class="cov8" title="1">
                if l.next == '&amp;' </span><span class="cov8" title="1">{
                        l.advance()
                        l.advance()
                        return interfaces.Token{Type: interfaces.TokenAnd, Value: "&amp;&amp;", Location: position}
                }</span>
        case '|':<span class="cov8" title="1">
                if l.next == '|' </span><span class="cov8" title="1">{
                        l.advance()
                        l.advance()
                        return interfaces.Token{Type: interfaces.TokenOr, Value: "||", Location: position}
                }</span>
        }

        // String literals
        <span class="cov8" title="1">if l.current == '"' </span><span class="cov8" title="1">{
                return l.readString(position)
        }</span>

        // Numeric literals
        <span class="cov8" title="1">if unicode.IsDigit(l.current) </span><span class="cov8" title="1">{
                return l.readNumber(position)
        }</span>

        // Identifiers and keywords
        <span class="cov8" title="1">if unicode.IsLetter(l.current) || l.current == '_' </span><span class="cov8" title="1">{
                return l.readIdentifier(position)
        }</span>

        // Unknown character
        <span class="cov8" title="1">char := string(l.current)
        l.advance()
        return interfaces.Token{
                Type:     interfaces.TokenError,
                Value:    fmt.Sprintf("unexpected character: %s", char),
                Location: position,
        }</span>
}

// Peek returns the next token without consuming it
func (l *StaticLangLexer) Peek() interfaces.Token <span class="cov8" title="1">{
        if l.peekedToken == nil </span><span class="cov8" title="1">{
                token := l.NextToken()
                l.peekedToken = &amp;token
        }</span>
        <span class="cov8" title="1">return *l.peekedToken</span>
}

// GetCurrentPosition returns the current position in the input
func (l *StaticLangLexer) GetCurrentPosition() domain.SourcePosition <span class="cov0" title="0">{
        return l.getCurrentPosition()
}</span>

// Helper methods

func (l *StaticLangLexer) getCurrentPosition() domain.SourcePosition <span class="cov8" title="1">{
        return domain.SourcePosition{
                Filename: l.filename,
                Line:     l.line,
                Column:   l.column,
                Offset:   l.offset,
        }
}</span>

func (l *StaticLangLexer) readChar() error <span class="cov8" title="1">{
        char, _, err := l.input.ReadRune()
        if err != nil </span><span class="cov8" title="1">{
                if err == io.EOF </span><span class="cov8" title="1">{
                        l.current = l.next
                        l.next = 0
                        l.hasNext = false
                        return err
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">l.current = l.next
        l.next = char
        l.hasNext = true

        if l.current == '\n' </span><span class="cov8" title="1">{
                l.line++
                l.column = 0
        }</span> else<span class="cov8" title="1"> {
                l.column++
        }</span>
        <span class="cov8" title="1">l.offset++

        return nil</span>
}

func (l *StaticLangLexer) advance() <span class="cov8" title="1">{
        l.readChar()
}</span>

func (l *StaticLangLexer) skipWhitespace() <span class="cov8" title="1">{
        for unicode.IsSpace(l.current) </span><span class="cov8" title="1">{
                l.advance()
        }</span>
}

func (l *StaticLangLexer) readString(position domain.SourcePosition) interfaces.Token <span class="cov8" title="1">{
        var value strings.Builder
        l.advance() // Skip opening quote

        for l.current != '"' &amp;&amp; l.current != 0 </span><span class="cov8" title="1">{
                if l.current == '\\' </span><span class="cov8" title="1">{
                        l.advance()
                        switch l.current </span>{
                        case 'n':<span class="cov8" title="1">
                                value.WriteRune('\n')</span>
                        case 't':<span class="cov8" title="1">
                                value.WriteRune('\t')</span>
                        case 'r':<span class="cov0" title="0">
                                value.WriteRune('\r')</span>
                        case '\\':<span class="cov8" title="1">
                                value.WriteRune('\\')</span>
                        case '"':<span class="cov8" title="1">
                                value.WriteRune('"')</span>
                        default:<span class="cov0" title="0">
                                value.WriteRune(l.current)</span>
                        }
                } else<span class="cov8" title="1"> {
                        value.WriteRune(l.current)
                }</span>
                <span class="cov8" title="1">l.advance()</span>
        }

        <span class="cov8" title="1">if l.current == 0 </span><span class="cov8" title="1">{
                return interfaces.Token{
                        Type:     interfaces.TokenError,
                        Value:    "unterminated string literal",
                        Location: position,
                }
        }</span>

        <span class="cov8" title="1">l.advance() // Skip closing quote

        return interfaces.Token{
                Type:     interfaces.TokenString,
                Value:    value.String(),
                Location: position,
        }</span>
}

func (l *StaticLangLexer) readNumber(position domain.SourcePosition) interfaces.Token <span class="cov8" title="1">{
        var value strings.Builder
        tokenType := interfaces.TokenInt

        // Read integer part
        for unicode.IsDigit(l.current) </span><span class="cov8" title="1">{
                value.WriteRune(l.current)
                l.advance()
        }</span>

        // Check for decimal point
        <span class="cov8" title="1">if l.current == '.' &amp;&amp; unicode.IsDigit(l.next) </span><span class="cov8" title="1">{
                tokenType = interfaces.TokenFloat
                value.WriteRune(l.current)
                l.advance()

                // Read fractional part
                for unicode.IsDigit(l.current) </span><span class="cov8" title="1">{
                        value.WriteRune(l.current)
                        l.advance()
                }</span>
        }

        <span class="cov8" title="1">str := value.String()

        // Validate the number
        if tokenType == interfaces.TokenInt </span><span class="cov8" title="1">{
                if _, err := strconv.ParseInt(str, 10, 64); err != nil </span><span class="cov0" title="0">{
                        return interfaces.Token{
                                Type:     interfaces.TokenError,
                                Value:    fmt.Sprintf("invalid integer: %s", str),
                                Location: position,
                        }
                }</span>
        } else<span class="cov8" title="1"> {
                if _, err := strconv.ParseFloat(str, 64); err != nil </span><span class="cov0" title="0">{
                        return interfaces.Token{
                                Type:     interfaces.TokenError,
                                Value:    fmt.Sprintf("invalid float: %s", str),
                                Location: position,
                        }
                }</span>
        }

        <span class="cov8" title="1">return interfaces.Token{
                Type:     tokenType,
                Value:    str,
                Location: position,
        }</span>
}

func (l *StaticLangLexer) readIdentifier(position domain.SourcePosition) interfaces.Token <span class="cov8" title="1">{
        var value strings.Builder

        for unicode.IsLetter(l.current) || unicode.IsDigit(l.current) || l.current == '_' </span><span class="cov8" title="1">{
                value.WriteRune(l.current)
                l.advance()
        }</span>

        <span class="cov8" title="1">str := value.String()
        tokenType := interfaces.TokenIdentifier

        // Check if it's a keyword
        if keywordType, isKeyword := keywords[str]; isKeyword </span><span class="cov8" title="1">{
                tokenType = keywordType
        }</span>

        <span class="cov8" title="1">return interfaces.Token{
                Type:     tokenType,
                Value:    str,
                Location: position,
        }</span>
}

// skipComment skips a single-line comment starting with //
func (l *StaticLangLexer) skipComment() <span class="cov8" title="1">{
        // Skip the first '/'
        l.advance()
        // Skip the second '/'
        l.advance()

        // Skip until end of line or end of input
        for l.current != '\n' &amp;&amp; l.current != 0 </span><span class="cov8" title="1">{
                l.advance()
        }</span>

        // Skip the newline character if present
        <span class="cov8" title="1">if l.current == '\n' </span><span class="cov8" title="1">{
                l.advance()
        }</span>
}

// TokenTypeString returns a string representation of the token type
func TokenTypeString(t interfaces.TokenType) string <span class="cov0" title="0">{
        switch t </span>{
        case interfaces.TokenInt:<span class="cov0" title="0">
                return "INT"</span>
        case interfaces.TokenFloat:<span class="cov0" title="0">
                return "FLOAT"</span>
        case interfaces.TokenString:<span class="cov0" title="0">
                return "STRING"</span>
        case interfaces.TokenBool:<span class="cov0" title="0">
                return "BOOL"</span>
        case interfaces.TokenIdentifier:<span class="cov0" title="0">
                return "IDENTIFIER"</span>
        case interfaces.TokenFunc:<span class="cov0" title="0">
                return "FUNC"</span>
        case interfaces.TokenStruct:<span class="cov0" title="0">
                return "STRUCT"</span>
        case interfaces.TokenVar:<span class="cov0" title="0">
                return "VAR"</span>
        case interfaces.TokenIf:<span class="cov0" title="0">
                return "IF"</span>
        case interfaces.TokenElse:<span class="cov0" title="0">
                return "ELSE"</span>
        case interfaces.TokenWhile:<span class="cov0" title="0">
                return "WHILE"</span>
        case interfaces.TokenFor:<span class="cov0" title="0">
                return "FOR"</span>
        case interfaces.TokenReturn:<span class="cov0" title="0">
                return "RETURN"</span>
        case interfaces.TokenTrue:<span class="cov0" title="0">
                return "TRUE"</span>
        case interfaces.TokenFalse:<span class="cov0" title="0">
                return "FALSE"</span>
        case interfaces.TokenPlus:<span class="cov0" title="0">
                return "PLUS"</span>
        case interfaces.TokenMinus:<span class="cov0" title="0">
                return "MINUS"</span>
        case interfaces.TokenStar:<span class="cov0" title="0">
                return "STAR"</span>
        case interfaces.TokenSlash:<span class="cov0" title="0">
                return "SLASH"</span>
        case interfaces.TokenPercent:<span class="cov0" title="0">
                return "PERCENT"</span>
        case interfaces.TokenEqual:<span class="cov0" title="0">
                return "EQUAL"</span>
        case interfaces.TokenNotEqual:<span class="cov0" title="0">
                return "NOT_EQUAL"</span>
        case interfaces.TokenLess:<span class="cov0" title="0">
                return "LESS"</span>
        case interfaces.TokenLessEqual:<span class="cov0" title="0">
                return "LESS_EQUAL"</span>
        case interfaces.TokenGreater:<span class="cov0" title="0">
                return "GREATER"</span>
        case interfaces.TokenGreaterEqual:<span class="cov0" title="0">
                return "GREATER_EQUAL"</span>
        case interfaces.TokenAnd:<span class="cov0" title="0">
                return "AND"</span>
        case interfaces.TokenOr:<span class="cov0" title="0">
                return "OR"</span>
        case interfaces.TokenNot:<span class="cov0" title="0">
                return "NOT"</span>
        case interfaces.TokenAssign:<span class="cov0" title="0">
                return "ASSIGN"</span>
        case interfaces.TokenLeftParen:<span class="cov0" title="0">
                return "LEFT_PAREN"</span>
        case interfaces.TokenRightParen:<span class="cov0" title="0">
                return "RIGHT_PAREN"</span>
        case interfaces.TokenLeftBrace:<span class="cov0" title="0">
                return "LEFT_BRACE"</span>
        case interfaces.TokenRightBrace:<span class="cov0" title="0">
                return "RIGHT_BRACE"</span>
        case interfaces.TokenLeftBracket:<span class="cov0" title="0">
                return "LEFT_BRACKET"</span>
        case interfaces.TokenRightBracket:<span class="cov0" title="0">
                return "RIGHT_BRACKET"</span>
        case interfaces.TokenSemicolon:<span class="cov0" title="0">
                return "SEMICOLON"</span>
        case interfaces.TokenComma:<span class="cov0" title="0">
                return "COMMA"</span>
        case interfaces.TokenDot:<span class="cov0" title="0">
                return "DOT"</span>
        case interfaces.TokenColon:<span class="cov0" title="0">
                return "COLON"</span>
        case interfaces.TokenArrow:<span class="cov0" title="0">
                return "ARROW"</span>
        case interfaces.TokenEOF:<span class="cov0" title="0">
                return "EOF"</span>
        case interfaces.TokenError:<span class="cov0" title="0">
                return "ERROR"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package semantic provides semantic analysis for the StaticLang compiler
package semantic

import (
        "fmt"

        "github.com/sokoide/llvm5/internal/domain"
        "github.com/sokoide/llvm5/internal/interfaces"
)

// Analyzer implements the SemanticAnalyzer interface
type Analyzer struct {
        typeRegistry    domain.TypeRegistry
        symbolTable     interfaces.SymbolTable
        errorReporter   domain.ErrorReporter
        currentFunction *domain.FunctionDecl
}

// NewAnalyzer creates a new semantic analyzer
func NewAnalyzer() *Analyzer <span class="cov8" title="1">{
        return &amp;Analyzer{
                typeRegistry: domain.NewDefaultTypeRegistry(),
        }
}</span>

// Analyze performs semantic analysis on the AST
func (a *Analyzer) Analyze(ast *domain.Program) error <span class="cov8" title="1">{
        // Initialize builtin functions first
        if err := a.initializeBuiltinFunctions(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // First pass: collect all function and struct declarations
        <span class="cov8" title="1">for _, decl := range ast.Declarations </span><span class="cov8" title="1">{
                if err := a.declareTopLevelSymbol(decl); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Second pass: analyze function bodies
        <span class="cov8" title="1">for _, decl := range ast.Declarations </span><span class="cov8" title="1">{
                if err := decl.Accept(a); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// SetTypeRegistry sets the type registry
func (a *Analyzer) SetTypeRegistry(registry domain.TypeRegistry) <span class="cov8" title="1">{
        a.typeRegistry = registry
}</span>

// SetSymbolTable sets the symbol table
func (a *Analyzer) SetSymbolTable(symbolTable interfaces.SymbolTable) <span class="cov8" title="1">{
        a.symbolTable = symbolTable
}</span>

// SetErrorReporter sets the error reporter
func (a *Analyzer) SetErrorReporter(reporter domain.ErrorReporter) <span class="cov8" title="1">{
        a.errorReporter = reporter
}</span>

// declareTopLevelSymbol declares function and struct symbols in the global scope
func (a *Analyzer) declareTopLevelSymbol(decl domain.Declaration) error <span class="cov8" title="1">{
        switch d := decl.(type) </span>{
        case *domain.FunctionDecl:<span class="cov8" title="1">
                // Create function type
                paramTypes := make([]domain.Type, len(d.Parameters))
                for i, param := range d.Parameters </span><span class="cov0" title="0">{
                        paramTypes[i] = param.Type
                }</span>

                <span class="cov8" title="1">funcType := &amp;domain.FunctionType{
                        ParameterTypes: paramTypes,
                        ReturnType:     d.ReturnType,
                }

                // Declare function symbol
                _, err := a.symbolTable.DeclareSymbol(
                        d.Name,
                        funcType,
                        interfaces.FunctionSymbol,
                        d.GetLocation(),
                )
                return err</span>

        case *domain.StructDecl:<span class="cov0" title="0">
                // Create struct type
                structType, err := a.typeRegistry.CreateStructType(d.Name, d.Fields)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Declare struct symbol
                <span class="cov0" title="0">_, err = a.symbolTable.DeclareSymbol(
                        d.Name,
                        structType,
                        interfaces.StructSymbol,
                        d.GetLocation(),
                )
                return err</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown declaration type: %T", decl)</span>
        }
}

// reportError reports a semantic error
func (a *Analyzer) reportError(errorType domain.ErrorType, message string, location domain.SourceRange, context string, hints []string) <span class="cov8" title="1">{
        if a.errorReporter != nil </span><span class="cov8" title="1">{
                err := domain.CompilerError{
                        Type:     errorType,
                        Message:  message,
                        Location: location,
                        Context:  context,
                        Hints:    hints,
                }
                a.errorReporter.ReportError(err)
        }</span>
}

// Visitor pattern implementation for semantic analysis

// VisitProgram analyzes the program node
func (a *Analyzer) VisitProgram(prog *domain.Program) error <span class="cov8" title="1">{
        for _, decl := range prog.Declarations </span><span class="cov8" title="1">{
                if err := decl.Accept(a); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// initializeBuiltinFunctions adds builtin functions to the symbol table
func (a *Analyzer) initializeBuiltinFunctions() error <span class="cov8" title="1">{
        // Define builtin function types
        builtinFunctions := map[string]*domain.FunctionType{
                "print": {
                        ParameterTypes: []domain.Type{}, // Variadic - will be handled specially
                        ReturnType:     domain.NewVoidType(),
                },
        }

        // Add builtin functions to symbol table
        for name, funcType := range builtinFunctions </span><span class="cov8" title="1">{
                _, err := a.symbolTable.DeclareSymbol(
                        name,
                        funcType,
                        interfaces.FunctionSymbol,
                        domain.SourceRange{}, // Builtin functions have no source location
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to declare builtin function %s: %v", name, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// VisitFunctionDecl analyzes function declarations
func (a *Analyzer) VisitFunctionDecl(decl *domain.FunctionDecl) error <span class="cov8" title="1">{
        a.currentFunction = decl
        defer func() </span><span class="cov8" title="1">{ a.currentFunction = nil }</span>()

        // Enter function scope
        <span class="cov8" title="1">a.symbolTable.EnterScope()
        defer a.symbolTable.ExitScope()

        // Declare parameters in function scope
        for _, param := range decl.Parameters </span><span class="cov8" title="1">{
                _, err := a.symbolTable.DeclareSymbol(
                        param.Name,
                        param.Type,
                        interfaces.ParameterSymbol,
                        decl.GetLocation(),
                )
                if err != nil </span><span class="cov0" title="0">{
                        a.reportError(
                                domain.SemanticError,
                                fmt.Sprintf("duplicate parameter: %s", param.Name),
                                decl.GetLocation(),
                                "in function declaration",
                                []string{"parameter names must be unique within a function"},
                        )
                }</span>
        }

        // Analyze function body
        <span class="cov8" title="1">if decl.Body != nil </span><span class="cov8" title="1">{
                return decl.Body.Accept(a)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// VisitStructDecl analyzes struct declarations
func (a *Analyzer) VisitStructDecl(decl *domain.StructDecl) error <span class="cov8" title="1">{
        // Struct analysis is mostly done during declaration phase
        // Additional validation can be added here if needed
        return nil
}</span>

// VisitBlockStmt analyzes block statements
func (a *Analyzer) VisitBlockStmt(stmt *domain.BlockStmt) error <span class="cov8" title="1">{
        // Enter new scope for block
        a.symbolTable.EnterScope()
        defer a.symbolTable.ExitScope()

        for _, s := range stmt.Statements </span><span class="cov8" title="1">{
                if err := s.Accept(a); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// VisitVarDeclStmt analyzes variable declarations
func (a *Analyzer) VisitVarDeclStmt(stmt *domain.VarDeclStmt) error <span class="cov8" title="1">{
        // Check if initializer exists and type check it
        if stmt.Initializer != nil </span><span class="cov8" title="1">{
                if err := stmt.Initializer.Accept(a); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Type check assignment
                <span class="cov8" title="1">initType := stmt.Initializer.GetType()
                if !stmt.Type_.IsAssignableFrom(initType) </span><span class="cov0" title="0">{
                        a.reportError(
                                domain.TypeCheckError,
                                fmt.Sprintf("cannot assign %s to variable of type %s", initType.String(), stmt.Type_.String()),
                                stmt.GetLocation(),
                                "in variable declaration",
                                []string{"ensure the initializer expression matches the declared type"},
                        )
                }</span>
        }

        // Declare variable symbol
        <span class="cov8" title="1">_, err := a.symbolTable.DeclareSymbol(
                stmt.Name,
                stmt.Type_,
                interfaces.VariableSymbol,
                stmt.GetLocation(),
        )
        if err != nil </span><span class="cov0" title="0">{
                a.reportError(
                        domain.SemanticError,
                        fmt.Sprintf("variable '%s' already declared", stmt.Name),
                        stmt.GetLocation(),
                        "in variable declaration",
                        []string{"variable names must be unique within a scope"},
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// VisitAssignStmt analyzes assignment statements
func (a *Analyzer) VisitAssignStmt(stmt *domain.AssignStmt) error <span class="cov8" title="1">{
        // Analyze target and value expressions
        if err := stmt.Target.Accept(a); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := stmt.Value.Accept(a); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Type check assignment
        <span class="cov8" title="1">targetType := stmt.Target.GetType()
        valueType := stmt.Value.GetType()

        if !targetType.IsAssignableFrom(valueType) </span><span class="cov8" title="1">{
                a.reportError(
                        domain.TypeCheckError,
                        fmt.Sprintf("cannot assign %s to %s", valueType.String(), targetType.String()),
                        stmt.GetLocation(),
                        "in assignment",
                        []string{"ensure both sides of assignment have compatible types"},
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// VisitIfStmt analyzes if statements
func (a *Analyzer) VisitIfStmt(stmt *domain.IfStmt) error <span class="cov8" title="1">{
        // Analyze condition
        if err := stmt.Condition.Accept(a); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check condition type
        <span class="cov8" title="1">condType := stmt.Condition.GetType()
        boolType := a.typeRegistry.GetBuiltinType(domain.BoolType)
        if !condType.Equals(boolType) </span><span class="cov0" title="0">{
                a.reportError(
                        domain.TypeCheckError,
                        fmt.Sprintf("if condition must be bool, got %s", condType.String()),
                        stmt.Condition.GetLocation(),
                        "in if statement",
                        []string{"use a boolean expression as the condition"},
                )
        }</span>

        // Analyze then statement
        <span class="cov8" title="1">if err := stmt.ThenStmt.Accept(a); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Analyze else statement if present
        <span class="cov8" title="1">if stmt.ElseStmt != nil </span><span class="cov8" title="1">{
                if err := stmt.ElseStmt.Accept(a); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// VisitWhileStmt analyzes while statements
func (a *Analyzer) VisitWhileStmt(stmt *domain.WhileStmt) error <span class="cov8" title="1">{
        // Analyze condition
        if err := stmt.Condition.Accept(a); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check condition type
        <span class="cov8" title="1">condType := stmt.Condition.GetType()
        boolType := a.typeRegistry.GetBuiltinType(domain.BoolType)
        if !condType.Equals(boolType) </span><span class="cov0" title="0">{
                a.reportError(
                        domain.TypeCheckError,
                        fmt.Sprintf("while condition must be bool, got %s", condType.String()),
                        stmt.Condition.GetLocation(),
                        "in while statement",
                        []string{"use a boolean expression as the condition"},
                )
        }</span>

        // Analyze body
        <span class="cov8" title="1">return stmt.Body.Accept(a)</span>
}

// VisitForStmt analyzes for statements
func (a *Analyzer) VisitForStmt(stmt *domain.ForStmt) error <span class="cov8" title="1">{
        // Enter new scope for for loop
        a.symbolTable.EnterScope()
        defer a.symbolTable.ExitScope()

        // Analyze init statement
        if stmt.Init != nil </span><span class="cov8" title="1">{
                if err := stmt.Init.Accept(a); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Analyze condition
        <span class="cov8" title="1">if stmt.Condition != nil </span><span class="cov8" title="1">{
                if err := stmt.Condition.Accept(a); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Check condition type
                <span class="cov8" title="1">condType := stmt.Condition.GetType()
                boolType := a.typeRegistry.GetBuiltinType(domain.BoolType)
                if !condType.Equals(boolType) </span><span class="cov0" title="0">{
                        a.reportError(
                                domain.TypeCheckError,
                                fmt.Sprintf("for condition must be bool, got %s", condType.String()),
                                stmt.Condition.GetLocation(),
                                "in for statement",
                                []string{"use a boolean expression as the condition"},
                        )
                }</span>
        }

        // Analyze update statement
        <span class="cov8" title="1">if stmt.Update != nil </span><span class="cov8" title="1">{
                if err := stmt.Update.Accept(a); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Analyze body
        <span class="cov8" title="1">return stmt.Body.Accept(a)</span>
}

// VisitReturnStmt analyzes return statements
func (a *Analyzer) VisitReturnStmt(stmt *domain.ReturnStmt) error <span class="cov8" title="1">{
        if a.currentFunction == nil </span><span class="cov8" title="1">{
                a.reportError(
                        domain.SemanticError,
                        "return statement outside function",
                        stmt.GetLocation(),
                        "",
                        []string{"return statements can only be used inside functions"},
                )
                return nil
        }</span>

        <span class="cov8" title="1">expectedReturnType := a.currentFunction.ReturnType

        if stmt.Value == nil </span><span class="cov0" title="0">{
                // Void return
                voidType := a.typeRegistry.GetBuiltinType(domain.VoidType)
                if !expectedReturnType.Equals(voidType) </span><span class="cov0" title="0">{
                        a.reportError(
                                domain.TypeCheckError,
                                fmt.Sprintf("function expects return value of type %s", expectedReturnType.String()),
                                stmt.GetLocation(),
                                "in return statement",
                                []string{"add a return value or change function return type to void"},
                        )
                }</span>
        } else<span class="cov8" title="1"> {
                // Analyze return value
                if err := stmt.Value.Accept(a); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">valueType := stmt.Value.GetType()
                if !expectedReturnType.IsAssignableFrom(valueType) </span><span class="cov0" title="0">{
                        a.reportError(
                                domain.TypeCheckError,
                                fmt.Sprintf("cannot return %s from function expecting %s", valueType.String(), expectedReturnType.String()),
                                stmt.GetLocation(),
                                "in return statement",
                                []string{"ensure return value matches function return type"},
                        )
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// VisitExprStmt analyzes expression statements
func (a *Analyzer) VisitExprStmt(stmt *domain.ExprStmt) error <span class="cov8" title="1">{
        return stmt.Expression.Accept(a)
}</span>

// VisitBinaryExpr analyzes binary expressions
func (a *Analyzer) VisitBinaryExpr(expr *domain.BinaryExpr) error <span class="cov8" title="1">{
        // Analyze operands
        if err := expr.Left.Accept(a); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := expr.Right.Accept(a); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">leftType := expr.Left.GetType()
        rightType := expr.Right.GetType()

        // Check if operation is valid
        if !domain.CanApplyBinaryOperator(expr.Operator, leftType, rightType) </span><span class="cov8" title="1">{
                a.reportError(
                        domain.TypeCheckError,
                        fmt.Sprintf("cannot apply operator %s to %s and %s", expr.Operator.String(), leftType.String(), rightType.String()),
                        expr.GetLocation(),
                        "in binary expression",
                        []string{"ensure operands have compatible types for the operator"},
                )
                expr.SetType(&amp;domain.TypeError{Message: "invalid binary operation"})
                return nil
        }</span>

        // Determine result type
        <span class="cov8" title="1">var resultType domain.Type
        switch expr.Operator </span>{
        case domain.Add, domain.Sub, domain.Mul, domain.Div, domain.Mod:<span class="cov8" title="1">
                resultType = leftType</span> // Arithmetic operations preserve type
        case domain.Eq, domain.Ne, domain.Lt, domain.Le, domain.Gt, domain.Ge:<span class="cov8" title="1">
                resultType = a.typeRegistry.GetBuiltinType(domain.BoolType)</span> // Comparison operations return bool
        case domain.And, domain.Or:<span class="cov0" title="0">
                resultType = a.typeRegistry.GetBuiltinType(domain.BoolType)</span> // Logical operations return bool
        default:<span class="cov0" title="0">
                resultType = &amp;domain.TypeError{Message: "unknown binary operator"}</span>
        }

        <span class="cov8" title="1">expr.SetType(resultType)
        return nil</span>
}

// VisitUnaryExpr analyzes unary expressions
func (a *Analyzer) VisitUnaryExpr(expr *domain.UnaryExpr) error <span class="cov8" title="1">{
        // Analyze operand
        if err := expr.Operand.Accept(a); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">operandType := expr.Operand.GetType()

        // Check if operation is valid
        if !domain.CanApplyUnaryOperator(expr.Operator, operandType) </span><span class="cov0" title="0">{
                a.reportError(
                        domain.TypeCheckError,
                        fmt.Sprintf("cannot apply operator %s to %s", expr.Operator.String(), operandType.String()),
                        expr.GetLocation(),
                        "in unary expression",
                        []string{"ensure operand has compatible type for the operator"},
                )
                expr.SetType(&amp;domain.TypeError{Message: "invalid unary operation"})
                return nil
        }</span>

        // Result type is same as operand for unary operations
        <span class="cov8" title="1">expr.SetType(operandType)
        return nil</span>
}

// VisitCallExpr analyzes function call expressions
func (a *Analyzer) VisitCallExpr(expr *domain.CallExpr) error <span class="cov8" title="1">{
        // Analyze function expression
        if err := expr.Function.Accept(a); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">funcType, ok := expr.Function.GetType().(*domain.FunctionType)
        if !ok </span><span class="cov0" title="0">{
                a.reportError(
                        domain.TypeCheckError,
                        fmt.Sprintf("cannot call non-function type %s", expr.Function.GetType().String()),
                        expr.GetLocation(),
                        "in function call",
                        []string{"ensure the expression is a function"},
                )
                expr.SetType(&amp;domain.TypeError{Message: "invalid function call"})
                return nil
        }</span>

        // Special handling for builtin functions
        <span class="cov8" title="1">if identExpr, ok := expr.Function.(*domain.IdentifierExpr); ok </span><span class="cov8" title="1">{
                if identExpr.Name == "print" </span><span class="cov0" title="0">{
                        // Special handling for print function - it's variadic
                        return a.handlePrintFunction(expr)
                }</span>
        }

        // Check argument count for regular functions
        <span class="cov8" title="1">if len(expr.Args) != len(funcType.ParameterTypes) </span><span class="cov0" title="0">{
                a.reportError(
                        domain.TypeCheckError,
                        fmt.Sprintf("function expects %d arguments, got %d", len(funcType.ParameterTypes), len(expr.Args)),
                        expr.GetLocation(),
                        "in function call",
                        []string{"provide the correct number of arguments"},
                )
        }</span>

        // Analyze and type check arguments
        <span class="cov8" title="1">for i, arg := range expr.Args </span><span class="cov8" title="1">{
                if err := arg.Accept(a); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if i &lt; len(funcType.ParameterTypes) </span><span class="cov8" title="1">{
                        expectedType := funcType.ParameterTypes[i]
                        actualType := arg.GetType()

                        if !expectedType.IsAssignableFrom(actualType) </span><span class="cov0" title="0">{
                                a.reportError(
                                        domain.TypeCheckError,
                                        fmt.Sprintf("argument %d: cannot pass %s to parameter of type %s", i+1, actualType.String(), expectedType.String()),
                                        arg.GetLocation(),
                                        "in function call",
                                        []string{"ensure argument types match parameter types"},
                                )
                        }</span>
                }
        }

        <span class="cov8" title="1">expr.SetType(funcType.ReturnType)
        return nil</span>
}

// handlePrintFunction performs special validation for the print builtin function
func (a *Analyzer) handlePrintFunction(expr *domain.CallExpr) error <span class="cov0" title="0">{
        // Analyze all arguments
        for _, arg := range expr.Args </span><span class="cov0" title="0">{
                if err := arg.Accept(a); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Print function validation logic
        <span class="cov0" title="0">if len(expr.Args) == 0 </span><span class="cov0" title="0">{
                a.reportError(
                        domain.SemanticError,
                        "print function requires at least one argument",
                        expr.GetLocation(),
                        "in print function call",
                        []string{"provide at least one argument to print"},
                )
                expr.SetType(&amp;domain.TypeError{Message: "invalid print call"})
                return nil
        }</span>

        // For now, accept any argument types for print function
        // The code generator will handle type-specific formatting
        <span class="cov0" title="0">expr.SetType(domain.NewVoidType())
        return nil</span>
}

// VisitIdentifierExpr analyzes identifier expressions
func (a *Analyzer) VisitIdentifierExpr(expr *domain.IdentifierExpr) error <span class="cov8" title="1">{
        // Look up symbol
        symbol, found := a.symbolTable.LookupSymbol(expr.Name)
        if !found </span><span class="cov8" title="1">{
                a.reportError(
                        domain.SemanticError,
                        fmt.Sprintf("undefined identifier: %s", expr.Name),
                        expr.GetLocation(),
                        "",
                        []string{"ensure the identifier is declared before use"},
                )
                expr.SetType(&amp;domain.TypeError{Message: "undefined identifier"})
                return nil
        }</span>

        <span class="cov8" title="1">expr.SetType(symbol.Type)
        return nil</span>
}

// VisitLiteralExpr analyzes literal expressions
func (a *Analyzer) VisitLiteralExpr(expr *domain.LiteralExpr) error <span class="cov8" title="1">{
        // Determine type based on value
        var literalType domain.Type

        switch v := expr.Value.(type) </span>{
        case int64:<span class="cov8" title="1">
                literalType = a.typeRegistry.GetBuiltinType(domain.IntType)</span>
        case float64:<span class="cov8" title="1">
                literalType = a.typeRegistry.GetBuiltinType(domain.FloatType)</span>
        case string:<span class="cov8" title="1">
                literalType = a.typeRegistry.GetBuiltinType(domain.StringType)</span>
        case bool:<span class="cov8" title="1">
                literalType = a.typeRegistry.GetBuiltinType(domain.BoolType)</span>
        default:<span class="cov0" title="0">
                literalType = &amp;domain.TypeError{Message: fmt.Sprintf("unknown literal type: %T", v)}</span>
        }

        <span class="cov8" title="1">expr.SetType(literalType)
        return nil</span>
}

// VisitIndexExpr analyzes array index expressions
func (a *Analyzer) VisitIndexExpr(expr *domain.IndexExpr) error <span class="cov8" title="1">{
        // Analyze object and index
        if err := expr.Object.Accept(a); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := expr.Index.Accept(a); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">objectType := expr.Object.GetType()
        indexType := expr.Index.GetType()

        // Check if object is an array
        arrayType, ok := objectType.(*domain.ArrayType)
        if !ok </span><span class="cov0" title="0">{
                a.reportError(
                        domain.TypeCheckError,
                        fmt.Sprintf("cannot index non-array type %s", objectType.String()),
                        expr.GetLocation(),
                        "in index expression",
                        []string{"ensure the object is an array"},
                )
                expr.SetType(&amp;domain.TypeError{Message: "invalid index operation"})
                return nil
        }</span>

        // Check if index is integer
        <span class="cov8" title="1">intType := a.typeRegistry.GetBuiltinType(domain.IntType)
        if !indexType.Equals(intType) </span><span class="cov0" title="0">{
                a.reportError(
                        domain.TypeCheckError,
                        fmt.Sprintf("array index must be int, got %s", indexType.String()),
                        expr.Index.GetLocation(),
                        "in index expression",
                        []string{"use an integer expression as the index"},
                )
        }</span>

        <span class="cov8" title="1">expr.SetType(arrayType.ElementType)
        return nil</span>
}

// VisitMemberExpr analyzes struct member access expressions
func (a *Analyzer) VisitMemberExpr(expr *domain.MemberExpr) error <span class="cov8" title="1">{
        // Analyze object
        if err := expr.Object.Accept(a); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">objectType := expr.Object.GetType()

        // Check if object is a struct
        structType, ok := objectType.(*domain.StructType)
        if !ok </span><span class="cov0" title="0">{
                a.reportError(
                        domain.TypeCheckError,
                        fmt.Sprintf("cannot access member of non-struct type %s", objectType.String()),
                        expr.GetLocation(),
                        "in member access",
                        []string{"ensure the object is a struct"},
                )
                expr.SetType(&amp;domain.TypeError{Message: "invalid member access"})
                return nil
        }</span>

        // Check if member exists
        <span class="cov8" title="1">memberType, exists := structType.GetField(expr.Member)
        if !exists </span><span class="cov0" title="0">{
                a.reportError(
                        domain.SemanticError,
                        fmt.Sprintf("struct %s has no member %s", structType.Name, expr.Member),
                        expr.GetLocation(),
                        "in member access",
                        []string{fmt.Sprintf("available members: %v", structType.Order)},
                )
                expr.SetType(&amp;domain.TypeError{Message: "undefined member"})
                return nil
        }</span>

        <span class="cov8" title="1">expr.SetType(memberType)
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
